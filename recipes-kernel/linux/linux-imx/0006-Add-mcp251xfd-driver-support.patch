From fb6babf6af45b2d8ccff561e8ed4a7b7dee92cac Mon Sep 17 00:00:00 2001
From: Alvaro-solidrun <alvaro.karsz@solid-run.com>
Date: Tue, 27 Apr 2021 17:20:01 +0300
Subject: [PATCH] Add support for mcp25xxfd driver

---
 .../net/can/microchip%2Cmcp251xfd.yaml        |   77 +
 drivers/net/can/Kconfig                       |    1 +
 drivers/net/can/Makefile                      |    7 +-
 drivers/net/can/c_can/c_can.c                 |   24 +-
 drivers/net/can/c_can/c_can_pci.c             |    3 +-
 drivers/net/can/c_can/c_can_platform.c        |    6 +-
 drivers/net/can/dev/Makefile                  |    7 +
 drivers/net/can/{ => dev}/dev.c               |   25 +-
 drivers/net/can/{ => dev}/rx-offload.c        |   15 +-
 drivers/net/can/flexcan.c                     |  154 +-
 drivers/net/can/kvaser_pciefd.c               |    8 +-
 drivers/net/can/m_can/Kconfig                 |    3 +-
 drivers/net/can/m_can/m_can.c                 |   32 +-
 drivers/net/can/m_can/m_can.h                 |    1 +
 drivers/net/can/m_can/m_can_platform.c        |    2 -
 drivers/net/can/m_can/tcan4x5x.c              |   42 +-
 drivers/net/can/peak_canfd/peak_canfd.c       |   11 +-
 drivers/net/can/slcan.c                       |    4 +-
 drivers/net/can/softing/softing_main.c        |    9 +-
 drivers/net/can/spi/Kconfig                   |    2 +
 drivers/net/can/spi/Makefile                  |    1 +
 drivers/net/can/spi/mcp251x.c                 |  148 +-
 drivers/net/can/spi/mcp25xxfd/Kconfig         |   25 +
 drivers/net/can/spi/mcp25xxfd/Makefile        |   11 +
 .../net/can/spi/mcp25xxfd/mcp25xxfd-core.c    | 2311 +++++++++++++++++
 .../net/can/spi/mcp25xxfd/mcp25xxfd-crc16.c   |   82 +
 .../net/can/spi/mcp25xxfd/mcp25xxfd-dump.c    |  685 +++++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c |  105 +
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h |  164 ++
 .../net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c  |  268 ++
 drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h     |  758 ++++++
 drivers/net/can/ti_hecc.c                     |   21 +-
 drivers/net/can/usb/gs_usb.c                  |  131 +-
 .../net/can/usb/kvaser_usb/kvaser_usb_hydra.c |    2 +-
 drivers/net/can/usb/mcba_usb.c                |    4 +-
 drivers/net/can/usb/peak_usb/pcan_usb_core.c  |   51 +-
 drivers/net/can/usb/peak_usb/pcan_usb_fd.c    |   56 +-
 drivers/net/can/vcan.c                        |    2 +-
 drivers/net/can/vxcan.c                       |   12 +-
 drivers/net/can/xilinx_can.c                  |    6 +-
 include/linux/can/can-ml.h                    |   12 +
 include/linux/can/platform/mcp251x.h          |   22 -
 include/linux/can/rx-offload.h                |    3 +
 include/linux/can/skb.h                       |   28 +-
 include/linux/netdevice.h                     |   41 +-
 include/net/rtnetlink.h                       |    2 +
 46 files changed, 5079 insertions(+), 305 deletions(-)
 create mode 100755 Documentation/devicetree/bindings/net/can/microchip%2Cmcp251xfd.yaml
 create mode 100644 drivers/net/can/dev/Makefile
 rename drivers/net/can/{ => dev}/dev.c (98%)
 rename drivers/net/can/{ => dev}/rx-offload.c (96%)
 create mode 100644 drivers/net/can/spi/mcp25xxfd/Kconfig
 create mode 100644 drivers/net/can/spi/mcp25xxfd/Makefile
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-crc16.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c
 create mode 100644 drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h
 delete mode 100644 include/linux/can/platform/mcp251x.h

diff --git a/Documentation/devicetree/bindings/net/can/microchip%2Cmcp251xfd.yaml b/Documentation/devicetree/bindings/net/can/microchip%2Cmcp251xfd.yaml
new file mode 100755
index 000000000000..a553d3ffeb03
--- /dev/null
+++ b/Documentation/devicetree/bindings/net/can/microchip%2Cmcp251xfd.yaml
@@ -0,0 +1,77 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/net/can/microchip,mcp251xfd.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title:
+  Microchip MCP2517FD and MCP2518FD stand-alone CAN controller device tree
+  bindings
+
+maintainers:
+  - Marc Kleine-Budde <mkl@pengutronix.de>
+
+properties:
+  compatible:
+    oneOf:
+      - const: microchip,mcp2517fd
+        description: for MCP2517FD
+      - const: microchip,mcp2518fd
+        description: for MCP2518FD
+      - const: microchip,mcp251xfd
+        description: to autodetect chip variant
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+  vdd-supply:
+    description: Regulator that powers the CAN controller.
+
+  xceiver-supply:
+    description: Regulator that powers the CAN transceiver.
+
+  microchip,rx-int-gpios:
+    description:
+      GPIO phandle of GPIO connected to to INT1 pin of the MCP251XFD, which
+      signals a pending RX interrupt.
+    maxItems: 1
+
+  spi-max-frequency:
+    description:
+      Must be half or less of "clocks" frequency.
+    maximum: 20000000
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+    #include <dt-bindings/interrupt-controller/irq.h>
+    spi0 {
+        #address-cells = <1>;
+        #size-cells = <0>;
+        can@0 {
+            compatible = "microchip,mcp251xfd";
+            reg = <0>;
+            clocks = <&can0_osc>;
+            pinctrl-names = "default";
+            pinctrl-0 = <&can0_pins>;
+            spi-max-frequency = <20000000>;
+            interrupts-extended = <&gpio 13 IRQ_TYPE_LEVEL_LOW>;
+            microchip,rx-int-gpios = <&gpio 27 GPIO_ACTIVE_LOW>;
+            vdd-supply = <&reg5v0>;
+            xceiver-supply = <&reg5v0>;
+        };
+    };
diff --git a/drivers/net/can/Kconfig b/drivers/net/can/Kconfig
index 17c166cc8482..e4d944770cca 100644
--- a/drivers/net/can/Kconfig
+++ b/drivers/net/can/Kconfig
@@ -123,6 +123,7 @@ config CAN_JANZ_ICAN3
 config CAN_KVASER_PCIEFD
 	depends on PCI
 	tristate "Kvaser PCIe FD cards"
+	select CRC32
 	  help
 	  This is a driver for the Kvaser PCI Express CAN FD family.
 
diff --git a/drivers/net/can/Makefile b/drivers/net/can/Makefile
index 22164300122d..a2b4463d8480 100644
--- a/drivers/net/can/Makefile
+++ b/drivers/net/can/Makefile
@@ -7,12 +7,7 @@ obj-$(CONFIG_CAN_VCAN)		+= vcan.o
 obj-$(CONFIG_CAN_VXCAN)		+= vxcan.o
 obj-$(CONFIG_CAN_SLCAN)		+= slcan.o
 
-obj-$(CONFIG_CAN_DEV)		+= can-dev.o
-can-dev-y			+= dev.o
-can-dev-y			+= rx-offload.o
-
-can-dev-$(CONFIG_CAN_LEDS)	+= led.o
-
+obj-y				+= dev/
 obj-y				+= rcar/
 obj-y				+= spi/
 obj-y				+= usb/
diff --git a/drivers/net/can/c_can/c_can.c b/drivers/net/can/c_can/c_can.c
index 8e9f5620c9a2..f14e739ba3f4 100644
--- a/drivers/net/can/c_can/c_can.c
+++ b/drivers/net/can/c_can/c_can.c
@@ -212,18 +212,6 @@ static const struct can_bittiming_const c_can_bittiming_const = {
 	.brp_inc = 1,
 };
 
-static inline void c_can_pm_runtime_enable(const struct c_can_priv *priv)
-{
-	if (priv->device)
-		pm_runtime_enable(priv->device);
-}
-
-static inline void c_can_pm_runtime_disable(const struct c_can_priv *priv)
-{
-	if (priv->device)
-		pm_runtime_disable(priv->device);
-}
-
 static inline void c_can_pm_runtime_get_sync(const struct c_can_priv *priv)
 {
 	if (priv->device)
@@ -1334,7 +1322,6 @@ static const struct net_device_ops c_can_netdev_ops = {
 
 int register_c_can_dev(struct net_device *dev)
 {
-	struct c_can_priv *priv = netdev_priv(dev);
 	int err;
 
 	/* Deactivate pins to prevent DRA7 DCAN IP from being
@@ -1344,28 +1331,19 @@ int register_c_can_dev(struct net_device *dev)
 	 */
 	pinctrl_pm_select_sleep_state(dev->dev.parent);
 
-	c_can_pm_runtime_enable(priv);
-
 	dev->flags |= IFF_ECHO;	/* we support local echo */
 	dev->netdev_ops = &c_can_netdev_ops;
 
 	err = register_candev(dev);
-	if (err)
-		c_can_pm_runtime_disable(priv);
-	else
+	if (!err)
 		devm_can_led_init(dev);
-
 	return err;
 }
 EXPORT_SYMBOL_GPL(register_c_can_dev);
 
 void unregister_c_can_dev(struct net_device *dev)
 {
-	struct c_can_priv *priv = netdev_priv(dev);
-
 	unregister_candev(dev);
-
-	c_can_pm_runtime_disable(priv);
 }
 EXPORT_SYMBOL_GPL(unregister_c_can_dev);
 
diff --git a/drivers/net/can/c_can/c_can_pci.c b/drivers/net/can/c_can/c_can_pci.c
index 406b4847e5dc..7efb60b50876 100644
--- a/drivers/net/can/c_can/c_can_pci.c
+++ b/drivers/net/can/c_can/c_can_pci.c
@@ -239,12 +239,13 @@ static void c_can_pci_remove(struct pci_dev *pdev)
 {
 	struct net_device *dev = pci_get_drvdata(pdev);
 	struct c_can_priv *priv = netdev_priv(dev);
+	void __iomem *addr = priv->base;
 
 	unregister_c_can_dev(dev);
 
 	free_c_can_dev(dev);
 
-	pci_iounmap(pdev, priv->base);
+	pci_iounmap(pdev, addr);
 	pci_disable_msi(pdev);
 	pci_clear_master(pdev);
 	pci_release_regions(pdev);
diff --git a/drivers/net/can/c_can/c_can_platform.c b/drivers/net/can/c_can/c_can_platform.c
index b5145a7f874c..f2b0408ce87d 100644
--- a/drivers/net/can/c_can/c_can_platform.c
+++ b/drivers/net/can/c_can/c_can_platform.c
@@ -29,6 +29,7 @@
 #include <linux/list.h>
 #include <linux/io.h>
 #include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/clk.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
@@ -385,6 +386,7 @@ static int c_can_plat_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, dev);
 	SET_NETDEV_DEV(dev, &pdev->dev);
 
+	pm_runtime_enable(priv->device);
 	ret = register_c_can_dev(dev);
 	if (ret) {
 		dev_err(&pdev->dev, "registering %s failed (err=%d)\n",
@@ -397,6 +399,7 @@ static int c_can_plat_probe(struct platform_device *pdev)
 	return 0;
 
 exit_free_device:
+	pm_runtime_disable(priv->device);
 	free_c_can_dev(dev);
 exit:
 	dev_err(&pdev->dev, "probe failed\n");
@@ -407,9 +410,10 @@ static int c_can_plat_probe(struct platform_device *pdev)
 static int c_can_plat_remove(struct platform_device *pdev)
 {
 	struct net_device *dev = platform_get_drvdata(pdev);
+	struct c_can_priv *priv = netdev_priv(dev);
 
 	unregister_c_can_dev(dev);
-
+	pm_runtime_disable(priv->device);
 	free_c_can_dev(dev);
 
 	return 0;
diff --git a/drivers/net/can/dev/Makefile b/drivers/net/can/dev/Makefile
new file mode 100644
index 000000000000..cba92e6bcf6f
--- /dev/null
+++ b/drivers/net/can/dev/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+
+obj-$(CONFIG_CAN_DEV)		+= can-dev.o
+can-dev-y			+= dev.o
+can-dev-y			+= rx-offload.o
+
+can-dev-$(CONFIG_CAN_LEDS)	+= led.o
diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev/dev.c
similarity index 98%
rename from drivers/net/can/dev.c
rename to drivers/net/can/dev/dev.c
index 3a33fb503400..322da89cb9c6 100644
--- a/drivers/net/can/dev.c
+++ b/drivers/net/can/dev/dev.c
@@ -486,9 +486,13 @@ __can_get_echo_skb(struct net_device *dev, unsigned int idx, u8 *len_ptr)
 		 */
 		struct sk_buff *skb = priv->echo_skb[idx];
 		struct canfd_frame *cf = (struct canfd_frame *)skb->data;
-		u8 len = cf->len;
 
-		*len_ptr = len;
+		/* get the real payload length for netdev statistics */
+		if (cf->can_id & CAN_RTR_FLAG)
+			*len_ptr = 0;
+		else
+			*len_ptr = cf->len;
+
 		priv->echo_skb[idx] = NULL;
 
 		return skb;
@@ -512,7 +516,11 @@ unsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx)
 	if (!skb)
 		return 0;
 
-	netif_rx(skb);
+	skb_get(skb);
+	if (netif_rx(skb) == NET_RX_SUCCESS)
+		dev_consume_skb_any(skb);
+	else
+		dev_kfree_skb_any(skb);
 
 	return len;
 }
@@ -559,11 +567,11 @@ static void can_restart(struct net_device *dev)
 	}
 	cf->can_id |= CAN_ERR_RESTARTED;
 
-	netif_rx(skb);
-
 	stats->rx_packets++;
 	stats->rx_bytes += cf->can_dlc;
 
+	netif_rx_ni(skb);
+
 restart:
 	netdev_dbg(dev, "restarted\n");
 	priv->can_stats.restarts++;
@@ -710,6 +718,7 @@ EXPORT_SYMBOL_GPL(alloc_can_err_skb);
 struct net_device *alloc_candev_mqs(int sizeof_priv, unsigned int echo_skb_max,
 				    unsigned int txqs, unsigned int rxqs)
 {
+	struct can_ml_priv *can_ml;
 	struct net_device *dev;
 	struct can_priv *priv;
 	int size;
@@ -741,7 +750,8 @@ struct net_device *alloc_candev_mqs(int sizeof_priv, unsigned int echo_skb_max,
 	priv = netdev_priv(dev);
 	priv->dev = dev;
 
-	dev->ml_priv = (void *)priv + ALIGN(sizeof_priv, NETDEV_ALIGN);
+	can_ml = (void *)priv + ALIGN(sizeof_priv, NETDEV_ALIGN);
+	can_set_ml_priv(dev, can_ml);
 
 	if (echo_skb_max) {
 		priv->echo_skb_max = echo_skb_max;
@@ -1126,7 +1136,7 @@ static int can_fill_info(struct sk_buff *skb, const struct net_device *dev)
 {
 	struct can_priv *priv = netdev_priv(dev);
 	struct can_ctrlmode cm = {.flags = priv->ctrlmode};
-	struct can_berr_counter bec;
+	struct can_berr_counter bec = { };
 	enum can_state state = priv->state;
 
 	if (priv->do_get_state)
@@ -1218,6 +1228,7 @@ static void can_dellink(struct net_device *dev, struct list_head *head)
 
 static struct rtnl_link_ops can_link_ops __read_mostly = {
 	.kind		= "can",
+	.netns_refund	= true,
 	.maxtype	= IFLA_CAN_MAX,
 	.policy		= can_policy,
 	.setup		= can_setup,
diff --git a/drivers/net/can/rx-offload.c b/drivers/net/can/dev/rx-offload.c
similarity index 96%
rename from drivers/net/can/rx-offload.c
rename to drivers/net/can/dev/rx-offload.c
index e3b9d44609fe..2946e00cba30 100644
--- a/drivers/net/can/rx-offload.c
+++ b/drivers/net/can/dev/rx-offload.c
@@ -245,7 +245,7 @@ int can_rx_offload_queue_sorted(struct can_rx_offload *offload,
 
 	if (skb_queue_len(&offload->skb_queue) >
 	    offload->skb_queue_len_max) {
-		kfree_skb(skb);
+		dev_kfree_skb_any(skb);
 		return -ENOBUFS;
 	}
 
@@ -290,7 +290,7 @@ int can_rx_offload_queue_tail(struct can_rx_offload *offload,
 {
 	if (skb_queue_len(&offload->skb_queue) >
 	    offload->skb_queue_len_max) {
-		kfree_skb(skb);
+		dev_kfree_skb_any(skb);
 		return -ENOBUFS;
 	}
 
@@ -351,6 +351,17 @@ int can_rx_offload_add_fifo(struct net_device *dev,
 }
 EXPORT_SYMBOL_GPL(can_rx_offload_add_fifo);
 
+int can_rx_offload_add_manual(struct net_device *dev,
+			      struct can_rx_offload *offload,
+			      unsigned int weight)
+{
+	if (offload->mailbox_read)
+		return -EINVAL;
+
+	return can_rx_offload_init_queue(dev, offload, weight);
+}
+EXPORT_SYMBOL_GPL(can_rx_offload_add_manual);
+
 void can_rx_offload_enable(struct can_rx_offload *offload)
 {
 	napi_enable(&offload->napi);
diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c
index 89c61d3dd95f..c7b348a173fa 100644
--- a/drivers/net/can/flexcan.c
+++ b/drivers/net/can/flexcan.c
@@ -24,6 +24,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/of_gpio.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/regulator/consumer.h>
@@ -351,6 +352,8 @@ struct flexcan_priv {
 	/* Read and Write APIs */
 	u32 (*read)(void __iomem *addr);
 	void (*write)(u32 val, void __iomem *addr);
+	int stby_gpio;
+	enum of_gpio_flags stby_gpio_flags;
 };
 
 static const struct flexcan_devtype_data fsl_p1010_devtype_data = {
@@ -402,8 +405,7 @@ static const struct flexcan_devtype_data fsl_lx2160a_r1_devtype_data = {
 
 static const struct flexcan_devtype_data fsl_ls1021a_r2_devtype_data = {
 	.quirks = FLEXCAN_QUIRK_DISABLE_RXFG | FLEXCAN_QUIRK_ENABLE_EACEN_RRS |
-		FLEXCAN_QUIRK_DISABLE_MECR | FLEXCAN_QUIRK_BROKEN_PERR_STATE |
-		FLEXCAN_QUIRK_USE_OFF_TIMESTAMP,
+		FLEXCAN_QUIRK_BROKEN_PERR_STATE | FLEXCAN_QUIRK_USE_OFF_TIMESTAMP,
 };
 
 static struct flexcan_devtype_data fsl_s32v234_devtype_data = {
@@ -644,6 +646,11 @@ static void flexcan_clks_disable(const struct flexcan_priv *priv)
 
 static inline int flexcan_transceiver_enable(const struct flexcan_priv *priv)
 {
+	if (gpio_is_valid(priv->stby_gpio)) {
+		gpio_set_value(priv->stby_gpio,
+			(priv->stby_gpio_flags & OF_GPIO_ACTIVE_LOW) ? 1 : 0);
+	}
+
 	if (!priv->reg_xceiver)
 		return 0;
 
@@ -652,6 +659,11 @@ static inline int flexcan_transceiver_enable(const struct flexcan_priv *priv)
 
 static inline int flexcan_transceiver_disable(const struct flexcan_priv *priv)
 {
+	if (gpio_is_valid(priv->stby_gpio)) {
+		gpio_set_value(priv->stby_gpio,
+			(priv->stby_gpio_flags & OF_GPIO_ACTIVE_LOW) ? 0 : 1);
+	}
+
 	if (!priv->reg_xceiver)
 		return 0;
 
@@ -685,11 +697,17 @@ static int flexcan_chip_disable(struct flexcan_priv *priv)
 static int flexcan_chip_freeze(struct flexcan_priv *priv)
 {
 	struct flexcan_regs __iomem *regs = priv->regs;
-	unsigned int timeout = 1000 * 1000 * 10 / priv->can.bittiming.bitrate;
+	unsigned int timeout;
+	u32 bitrate = priv->can.bittiming.bitrate;
 	u32 reg;
 
+	if (bitrate)
+		timeout = 1000 * 1000 * 10 / bitrate;
+	else
+		timeout = FLEXCAN_TIMEOUT_US / 10;
+
 	reg = priv->read(&regs->mcr);
-	reg |= FLEXCAN_MCR_HALT;
+	reg |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;
 	priv->write(reg, &regs->mcr);
 
 	while (timeout-- && !(priv->read(&regs->mcr) & FLEXCAN_MCR_FRZ_ACK))
@@ -755,8 +773,10 @@ static int flexcan_get_berr_counter(const struct net_device *dev,
 	int err;
 
 	err = pm_runtime_get_sync(priv->dev);
-	if (err < 0)
+	if (err < 0) {
+		pm_runtime_put_noidle(priv->dev);
 		return err;
+	}
 
 	err = __flexcan_get_berr_counter(dev, bec);
 
@@ -1420,10 +1440,13 @@ static int flexcan_chip_start(struct net_device *dev)
 	if (priv->devtype_data->quirks & FLEXCAN_QUIRK_DISABLE_MECR)
 		flexcan_init_ram(dev);
 
+	/* set freeze, halt */
+	err = flexcan_chip_freeze(priv);
+	if (err)
+		goto out_chip_disable;
+
 	/* MCR
 	 *
-	 * enable freeze
-	 * halt now
 	 * only supervisor access
 	 * enable warning int
 	 * enable individual RX masking
@@ -1432,9 +1455,8 @@ static int flexcan_chip_start(struct net_device *dev)
 	 */
 	reg_mcr = priv->read(&regs->mcr);
 	reg_mcr &= ~FLEXCAN_MCR_MAXMB(0xff);
-	reg_mcr |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT | FLEXCAN_MCR_SUPV |
-		FLEXCAN_MCR_WRN_EN | FLEXCAN_MCR_IRMQ | FLEXCAN_MCR_IDAM_C |
-		FLEXCAN_MCR_MAXMB(priv->tx_mb_idx);
+	reg_mcr |= FLEXCAN_MCR_SUPV | FLEXCAN_MCR_WRN_EN | FLEXCAN_MCR_IRMQ |
+		FLEXCAN_MCR_IDAM_C | FLEXCAN_MCR_MAXMB(priv->tx_mb_idx);
 
 	/* MCR
 	 *
@@ -1603,14 +1625,10 @@ static int flexcan_chip_start(struct net_device *dev)
 
 	}
 
-	err = flexcan_transceiver_enable(priv);
-	if (err)
-		goto out_chip_disable;
-
 	/* synchronize with the can bus */
 	err = flexcan_chip_unfreeze(priv);
 	if (err)
-		goto out_transceiver_disable;
+		goto out_chip_disable;
 
 	priv->can.state = CAN_STATE_ERROR_ACTIVE;
 
@@ -1628,25 +1646,28 @@ static int flexcan_chip_start(struct net_device *dev)
 
 	return 0;
 
- out_transceiver_disable:
-	flexcan_transceiver_disable(priv);
  out_chip_disable:
 	flexcan_chip_disable(priv);
 	return err;
 }
 
-/* flexcan_chip_stop
+/* __flexcan_chip_stop
  *
- * this functions is entered with clocks enabled
+ * this function is entered with clocks enabled
  */
-static void flexcan_chip_stop(struct net_device *dev)
+static int __flexcan_chip_stop(struct net_device *dev, bool disable_on_error)
 {
 	struct flexcan_priv *priv = netdev_priv(dev);
 	struct flexcan_regs __iomem *regs = priv->regs;
+	int err;
 
 	/* freeze + disable module */
-	flexcan_chip_freeze(priv);
-	flexcan_chip_disable(priv);
+	err = flexcan_chip_freeze(priv);
+	if (err && !disable_on_error)
+		return err;
+	err = flexcan_chip_disable(priv);
+	if (err && !disable_on_error)
+		goto out_chip_unfreeze;
 
 	/* Disable all interrupts */
 	priv->write(0, &regs->imask2);
@@ -1654,8 +1675,24 @@ static void flexcan_chip_stop(struct net_device *dev)
 	priv->write(priv->reg_ctrl_default & ~FLEXCAN_CTRL_ERR_ALL,
 		    &regs->ctrl);
 
-	flexcan_transceiver_disable(priv);
 	priv->can.state = CAN_STATE_STOPPED;
+
+	return 0;
+
+ out_chip_unfreeze:
+	flexcan_chip_unfreeze(priv);
+
+	return err;
+}
+
+static inline int flexcan_chip_stop_disable_on_error(struct net_device *dev)
+{
+	return __flexcan_chip_stop(dev, true);
+}
+
+static inline int flexcan_chip_stop(struct net_device *dev)
+{
+	return __flexcan_chip_stop(dev, false);
 }
 
 static int flexcan_open(struct net_device *dev)
@@ -1670,17 +1707,23 @@ static int flexcan_open(struct net_device *dev)
 	}
 
 	err = pm_runtime_get_sync(priv->dev);
-	if (err < 0)
+	if (err < 0) {
+		pm_runtime_put_noidle(priv->dev);
 		return err;
+	}
 
 	err = open_candev(dev);
 	if (err)
 		goto out_runtime_put;
 
-	err = request_irq(dev->irq, flexcan_irq, IRQF_SHARED, dev->name, dev);
+	err = flexcan_transceiver_enable(priv);
 	if (err)
 		goto out_close;
 
+	err = request_irq(dev->irq, flexcan_irq, IRQF_SHARED, dev->name, dev);
+	if (err)
+		goto out_transceiver_disable;
+
 	if (priv->can.ctrlmode & CAN_CTRLMODE_FD)
 		priv->mb_size = sizeof(struct flexcan_mb) + CANFD_MAX_DLEN;
 	else
@@ -1732,6 +1775,8 @@ static int flexcan_open(struct net_device *dev)
 	can_rx_offload_del(&priv->offload);
  out_free_irq:
 	free_irq(dev->irq, dev);
+ out_transceiver_disable:
+	flexcan_transceiver_disable(priv);
  out_close:
 	close_candev(dev);
  out_runtime_put:
@@ -1746,10 +1791,11 @@ static int flexcan_close(struct net_device *dev)
 
 	netif_stop_queue(dev);
 	can_rx_offload_disable(&priv->offload);
-	flexcan_chip_stop(dev);
+	flexcan_chip_stop_disable_on_error(dev);
 
 	can_rx_offload_del(&priv->offload);
 	free_irq(dev->irq, dev);
+	flexcan_transceiver_disable(priv);
 
 	close_candev(dev);
 	pm_runtime_put(priv->dev);
@@ -1812,10 +1858,14 @@ static int register_flexcandev(struct net_device *dev)
 	if (err)
 		goto out_chip_disable;
 
-	/* set freeze, halt and activate FIFO, restrict register access */
+	/* set freeze, halt */
+	err = flexcan_chip_freeze(priv);
+	if (err)
+		goto out_chip_disable;
+
+	/* activate FIFO, restrict register access */
 	reg = priv->read(&regs->mcr);
-	reg |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT |
-		FLEXCAN_MCR_FEN | FLEXCAN_MCR_SUPV;
+	reg |=  FLEXCAN_MCR_FEN | FLEXCAN_MCR_SUPV;
 	priv->write(reg, &regs->mcr);
 
 	/* Currently we only support newer versions of this core
@@ -2053,6 +2103,14 @@ static int flexcan_probe(struct platform_device *pdev)
 	priv->devtype_data = devtype_data;
 	priv->reg_xceiver = reg_xceiver;
 
+	priv->stby_gpio = of_get_named_gpio_flags(pdev->dev.of_node,
+						  "trx-stby-gpio", 0,
+						  &priv->stby_gpio_flags);
+	if (gpio_is_valid(priv->stby_gpio)){
+		gpio_request_one(priv->stby_gpio, GPIOF_DIR_OUT, "flexcan-trx-stby");
+		gpio_direction_output(priv->stby_gpio,1);
+	}
+
 	if (priv->devtype_data->quirks & FLEXCAN_QUIRK_TIMESTAMP_SUPPORT_FD) {
 		if (priv->devtype_data->quirks & FLEXCAN_QUIRK_USE_OFF_TIMESTAMP) {
 			priv->can.ctrlmode_supported |= CAN_CTRLMODE_FD | CAN_CTRLMODE_FD_NON_ISO;
@@ -2103,9 +2161,15 @@ static int flexcan_probe(struct platform_device *pdev)
 static int flexcan_remove(struct platform_device *pdev)
 {
 	struct net_device *dev = platform_get_drvdata(pdev);
+	struct flexcan_priv *priv = netdev_priv(dev);
 
+	device_set_wakeup_enable(&pdev->dev, false);
+	device_set_wakeup_capable(&pdev->dev, false);
 	unregister_flexcandev(dev);
 	pm_runtime_disable(&pdev->dev);
+	if (gpio_is_valid(priv->stby_gpio))
+		gpio_free(priv->stby_gpio);
+
 	free_candev(dev);
 
 	return 0;
@@ -2129,10 +2193,6 @@ static int __maybe_unused flexcan_suspend(struct device *device)
 		} else {
 			flexcan_chip_stop(dev);
 
-			err = pm_runtime_force_suspend(device);
-			if (err)
-				return err;
-
 			pinctrl_pm_select_sleep_state(device);
 		}
 		netif_stop_queue(dev);
@@ -2161,10 +2221,6 @@ static int __maybe_unused flexcan_resume(struct device *device)
 		} else {
 			pinctrl_pm_select_default_state(device);
 
-			err = pm_runtime_force_resume(device);
-			if (err)
-				return err;
-
 			err = flexcan_chip_start(dev);
 			if (err)
 				return err;
@@ -2197,8 +2253,16 @@ static int __maybe_unused flexcan_noirq_suspend(struct device *device)
 	struct net_device *dev = dev_get_drvdata(device);
 	struct flexcan_priv *priv = netdev_priv(dev);
 
-	if (netif_running(dev) && device_may_wakeup(device))
-		flexcan_enable_wakeup_irq(priv, true);
+	if (netif_running(dev)) {
+		int err;
+
+		if (device_may_wakeup(device))
+			flexcan_enable_wakeup_irq(priv, true);
+
+		err = pm_runtime_force_suspend(device);
+		if (err)
+			return err;
+	}
 
 	return 0;
 }
@@ -2208,8 +2272,16 @@ static int __maybe_unused flexcan_noirq_resume(struct device *device)
 	struct net_device *dev = dev_get_drvdata(device);
 	struct flexcan_priv *priv = netdev_priv(dev);
 
-	if (netif_running(dev) && device_may_wakeup(device))
-		flexcan_enable_wakeup_irq(priv, false);
+	if (netif_running(dev)) {
+		int err;
+
+		err = pm_runtime_force_resume(device);
+		if (err)
+			return err;
+
+		if (device_may_wakeup(device))
+			flexcan_enable_wakeup_irq(priv, false);
+	}
 
 	return 0;
 }
diff --git a/drivers/net/can/kvaser_pciefd.c b/drivers/net/can/kvaser_pciefd.c
index 6f766918211a..e7a26ec9bdc1 100644
--- a/drivers/net/can/kvaser_pciefd.c
+++ b/drivers/net/can/kvaser_pciefd.c
@@ -57,6 +57,7 @@ MODULE_DESCRIPTION("CAN driver for Kvaser CAN/PCIe devices");
 #define KVASER_PCIEFD_KCAN_STAT_REG 0x418
 #define KVASER_PCIEFD_KCAN_MODE_REG 0x41c
 #define KVASER_PCIEFD_KCAN_BTRN_REG 0x420
+#define KVASER_PCIEFD_KCAN_BUS_LOAD_REG 0x424
 #define KVASER_PCIEFD_KCAN_BTRD_REG 0x428
 #define KVASER_PCIEFD_KCAN_PWM_REG 0x430
 /* Loopback control register */
@@ -287,12 +288,12 @@ struct kvaser_pciefd_tx_packet {
 static const struct can_bittiming_const kvaser_pciefd_bittiming_const = {
 	.name = KVASER_PCIEFD_DRV_NAME,
 	.tseg1_min = 1,
-	.tseg1_max = 255,
+	.tseg1_max = 512,
 	.tseg2_min = 1,
 	.tseg2_max = 32,
 	.sjw_max = 16,
 	.brp_min = 1,
-	.brp_max = 4096,
+	.brp_max = 8192,
 	.brp_inc = 1,
 };
 
@@ -947,6 +948,9 @@ static int kvaser_pciefd_setup_can_ctrls(struct kvaser_pciefd *pcie)
 		timer_setup(&can->bec_poll_timer, kvaser_pciefd_bec_poll_timer,
 			    0);
 
+		/* Disable Bus load reporting */
+		iowrite32(0, can->reg_base + KVASER_PCIEFD_KCAN_BUS_LOAD_REG);
+
 		tx_npackets = ioread32(can->reg_base +
 				       KVASER_PCIEFD_KCAN_TX_NPACKETS_REG);
 		if (((tx_npackets >> KVASER_PCIEFD_KCAN_TX_NPACKETS_MAX_SHIFT) &
diff --git a/drivers/net/can/m_can/Kconfig b/drivers/net/can/m_can/Kconfig
index 1ff0b7fe81d6..c10932a7f1fe 100644
--- a/drivers/net/can/m_can/Kconfig
+++ b/drivers/net/can/m_can/Kconfig
@@ -16,7 +16,8 @@ config CAN_M_CAN_PLATFORM
 
 config CAN_M_CAN_TCAN4X5X
 	depends on CAN_M_CAN
-	depends on REGMAP_SPI
+	depends on SPI
+	select REGMAP_SPI
 	tristate "TCAN4X5X M_CAN device"
 	---help---
 	  Say Y here if you want support for Texas Instruments TCAN4x5x
diff --git a/drivers/net/can/m_can/m_can.c b/drivers/net/can/m_can/m_can.c
index 562c8317e3aa..b2224113987c 100644
--- a/drivers/net/can/m_can/m_can.c
+++ b/drivers/net/can/m_can/m_can.c
@@ -379,10 +379,6 @@ void m_can_config_endisable(struct m_can_classdev *cdev, bool enable)
 		cccr &= ~CCCR_CSR;
 
 	if (enable) {
-		/* Clear the Clock stop request if it was set */
-		if (cccr & CCCR_CSR)
-			cccr &= ~CCCR_CSR;
-
 		/* enable m_can configuration */
 		m_can_write(cdev, M_CAN_CCCR, cccr | CCCR_INIT);
 		udelay(5);
@@ -505,9 +501,6 @@ static int m_can_do_rx_poll(struct net_device *dev, int quota)
 	}
 
 	while ((rxfs & RXFS_FFL_MASK) && (quota > 0)) {
-		if (rxfs & RXFS_RFL)
-			netdev_warn(dev, "Rx FIFO 0 Message Lost\n");
-
 		m_can_read_fifo(dev, rxfs);
 
 		quota--;
@@ -664,7 +657,7 @@ static int m_can_handle_state_change(struct net_device *dev,
 	unsigned int ecr;
 
 	switch (new_state) {
-	case CAN_STATE_ERROR_ACTIVE:
+	case CAN_STATE_ERROR_WARNING:
 		/* error warning state */
 		cdev->can.can_stats.error_warning++;
 		cdev->can.state = CAN_STATE_ERROR_WARNING;
@@ -693,7 +686,7 @@ static int m_can_handle_state_change(struct net_device *dev,
 	__m_can_get_berr_counter(dev, &bec);
 
 	switch (new_state) {
-	case CAN_STATE_ERROR_ACTIVE:
+	case CAN_STATE_ERROR_WARNING:
 		/* error warning state */
 		cf->can_id |= CAN_ERR_CRTL;
 		cf->data[1] = (bec.txerr > bec.rxerr) ?
@@ -846,7 +839,7 @@ static int m_can_rx_peripheral(struct net_device *dev)
 {
 	struct m_can_classdev *cdev = netdev_priv(dev);
 
-	m_can_rx_handler(dev, 1);
+	m_can_rx_handler(dev, M_CAN_NAPI_WEIGHT);
 
 	m_can_enable_all_interrupts(cdev);
 
@@ -913,6 +906,8 @@ static irqreturn_t m_can_isr(int irq, void *dev_id)
 	struct net_device_stats *stats = &dev->stats;
 	u32 ir;
 
+	if (pm_runtime_suspended(cdev->dev))
+		return IRQ_NONE;
 	ir = m_can_read(cdev, M_CAN_IR);
 	if (!ir)
 		return IRQ_NONE;
@@ -988,7 +983,7 @@ static const struct can_bittiming_const m_can_bittiming_const_31X = {
 	.name = KBUILD_MODNAME,
 	.tseg1_min = 2,		/* Time segment 1 = prop_seg + phase_seg1 */
 	.tseg1_max = 256,
-	.tseg2_min = 1,		/* Time segment 2 = phase_seg2 */
+	.tseg2_min = 2,		/* Time segment 2 = phase_seg2 */
 	.tseg2_max = 128,
 	.sjw_max = 128,
 	.brp_min = 1,
@@ -1335,6 +1330,8 @@ static int m_can_dev_setup(struct m_can_classdev *m_can_dev)
 						&m_can_data_bittiming_const_31X;
 		break;
 	case 32:
+	case 33:
+		/* Support both MCAN version v3.2.x and v3.3.0 */
 		m_can_dev->can.bittiming_const = m_can_dev->bit_timing ?
 			m_can_dev->bit_timing : &m_can_bittiming_const_31X;
 
@@ -1366,6 +1363,9 @@ static void m_can_stop(struct net_device *dev)
 	/* disable all interrupts */
 	m_can_disable_all_interrupts(cdev);
 
+	/* Set init mode to disengage from the network */
+	m_can_config_endisable(cdev, true);
+
 	/* set the state as STOPPED */
 	cdev->can.state = CAN_STATE_STOPPED;
 }
@@ -1600,7 +1600,7 @@ static int m_can_open(struct net_device *dev)
 		INIT_WORK(&cdev->tx_work, m_can_tx_work_queue);
 
 		err = request_threaded_irq(dev->irq, NULL, m_can_isr,
-					   IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
+					   IRQF_ONESHOT,
 					   dev->name, dev);
 	} else {
 		err = request_irq(dev->irq, m_can_isr, IRQF_SHARED, dev->name,
@@ -1764,6 +1764,12 @@ struct m_can_classdev *m_can_class_allocate_dev(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(m_can_class_allocate_dev);
 
+void m_can_class_free_dev(struct net_device *net)
+{
+	free_candev(net);
+}
+EXPORT_SYMBOL_GPL(m_can_class_free_dev);
+
 int m_can_class_register(struct m_can_classdev *m_can_dev)
 {
 	int ret;
@@ -1859,8 +1865,6 @@ void m_can_class_unregister(struct m_can_classdev *m_can_dev)
 {
 	unregister_candev(m_can_dev->net);
 
-	m_can_clk_stop(m_can_dev);
-
 	free_candev(m_can_dev->net);
 }
 EXPORT_SYMBOL_GPL(m_can_class_unregister);
diff --git a/drivers/net/can/m_can/m_can.h b/drivers/net/can/m_can/m_can.h
index 49f42b50627a..b2699a7c9997 100644
--- a/drivers/net/can/m_can/m_can.h
+++ b/drivers/net/can/m_can/m_can.h
@@ -99,6 +99,7 @@ struct m_can_classdev {
 };
 
 struct m_can_classdev *m_can_class_allocate_dev(struct device *dev);
+void m_can_class_free_dev(struct net_device *net);
 int m_can_class_register(struct m_can_classdev *cdev);
 void m_can_class_unregister(struct m_can_classdev *cdev);
 int m_can_class_get_clocks(struct m_can_classdev *cdev);
diff --git a/drivers/net/can/m_can/m_can_platform.c b/drivers/net/can/m_can/m_can_platform.c
index 38ea5e600fb8..e6d0cb9ee02f 100644
--- a/drivers/net/can/m_can/m_can_platform.c
+++ b/drivers/net/can/m_can/m_can_platform.c
@@ -144,8 +144,6 @@ static int __maybe_unused m_can_runtime_suspend(struct device *dev)
 	struct net_device *ndev = dev_get_drvdata(dev);
 	struct m_can_classdev *mcan_class = netdev_priv(ndev);
 
-	m_can_class_suspend(dev);
-
 	clk_disable_unprepare(mcan_class->cclk);
 	clk_disable_unprepare(mcan_class->hclk);
 
diff --git a/drivers/net/can/m_can/tcan4x5x.c b/drivers/net/can/m_can/tcan4x5x.c
index b233756345f8..0d66582bd356 100644
--- a/drivers/net/can/m_can/tcan4x5x.c
+++ b/drivers/net/can/m_can/tcan4x5x.c
@@ -88,7 +88,7 @@
 
 #define TCAN4X5X_MRAM_START 0x8000
 #define TCAN4X5X_MCAN_OFFSET 0x1000
-#define TCAN4X5X_MAX_REGISTER 0x8fff
+#define TCAN4X5X_MAX_REGISTER 0x8ffc
 
 #define TCAN4X5X_CLEAR_ALL_INT 0xffffffff
 #define TCAN4X5X_SET_ALL_INT 0xffffffff
@@ -126,30 +126,6 @@ struct tcan4x5x_priv {
 	int reg_offset;
 };
 
-static struct can_bittiming_const tcan4x5x_bittiming_const = {
-	.name = DEVICE_NAME,
-	.tseg1_min = 2,
-	.tseg1_max = 31,
-	.tseg2_min = 2,
-	.tseg2_max = 16,
-	.sjw_max = 16,
-	.brp_min = 1,
-	.brp_max = 32,
-	.brp_inc = 1,
-};
-
-static struct can_bittiming_const tcan4x5x_data_bittiming_const = {
-	.name = DEVICE_NAME,
-	.tseg1_min = 1,
-	.tseg1_max = 32,
-	.tseg2_min = 1,
-	.tseg2_max = 16,
-	.sjw_max = 16,
-	.brp_min = 1,
-	.brp_max = 32,
-	.brp_inc = 1,
-};
-
 static void tcan4x5x_check_wake(struct tcan4x5x_priv *priv)
 {
 	int wake_state = 0;
@@ -349,14 +325,14 @@ static int tcan4x5x_init(struct m_can_classdev *cdev)
 	if (ret)
 		return ret;
 
+	/* Zero out the MCAN buffers */
+	m_can_init_ram(cdev);
+
 	ret = regmap_update_bits(tcan4x5x->regmap, TCAN4X5X_CONFIG,
 				 TCAN4X5X_MODE_SEL_MASK, TCAN4X5X_MODE_NORMAL);
 	if (ret)
 		return ret;
 
-	/* Zero out the MCAN buffers */
-	m_can_init_ram(cdev);
-
 	return ret;
 }
 
@@ -449,8 +425,6 @@ static int tcan4x5x_can_probe(struct spi_device *spi)
 	mcan_class->dev = &spi->dev;
 	mcan_class->ops = &tcan4x5x_ops;
 	mcan_class->is_peripheral = true;
-	mcan_class->bit_timing = &tcan4x5x_bittiming_const;
-	mcan_class->data_timing = &tcan4x5x_data_bittiming_const;
 	mcan_class->net->irq = spi->irq;
 
 	spi_set_drvdata(spi, priv);
@@ -467,6 +441,10 @@ static int tcan4x5x_can_probe(struct spi_device *spi)
 
 	priv->regmap = devm_regmap_init(&spi->dev, &tcan4x5x_bus,
 					&spi->dev, &tcan4x5x_regmap);
+	if (IS_ERR(priv->regmap)) {
+		ret = PTR_ERR(priv->regmap);
+		goto out_clk;
+	}
 
 	tcan4x5x_power_enable(priv->power, 1);
 
@@ -497,10 +475,10 @@ static int tcan4x5x_can_remove(struct spi_device *spi)
 {
 	struct tcan4x5x_priv *priv = spi_get_drvdata(spi);
 
-	tcan4x5x_power_enable(priv->power, 0);
-
 	m_can_class_unregister(priv->mcan_dev);
 
+	tcan4x5x_power_enable(priv->power, 0);
+
 	return 0;
 }
 
diff --git a/drivers/net/can/peak_canfd/peak_canfd.c b/drivers/net/can/peak_canfd/peak_canfd.c
index 6b0c6a99fc8d..91b156b2123a 100644
--- a/drivers/net/can/peak_canfd/peak_canfd.c
+++ b/drivers/net/can/peak_canfd/peak_canfd.c
@@ -248,8 +248,7 @@ static int pucan_handle_can_rx(struct peak_canfd_priv *priv,
 		cf_len = get_can_dlc(pucan_msg_get_dlc(msg));
 
 	/* if this frame is an echo, */
-	if ((rx_msg_flags & PUCAN_MSG_LOOPED_BACK) &&
-	    !(rx_msg_flags & PUCAN_MSG_SELF_RECEIVE)) {
+	if (rx_msg_flags & PUCAN_MSG_LOOPED_BACK) {
 		unsigned long flags;
 
 		spin_lock_irqsave(&priv->echo_lock, flags);
@@ -263,7 +262,13 @@ static int pucan_handle_can_rx(struct peak_canfd_priv *priv,
 		netif_wake_queue(priv->ndev);
 
 		spin_unlock_irqrestore(&priv->echo_lock, flags);
-		return 0;
+
+		/* if this frame is only an echo, stop here. Otherwise,
+		 * continue to push this application self-received frame into
+		 * its own rx queue.
+		 */
+		if (!(rx_msg_flags & PUCAN_MSG_SELF_RECEIVE))
+			return 0;
 	}
 
 	/* otherwise, it should be pushed into rx fifo */
diff --git a/drivers/net/can/slcan.c b/drivers/net/can/slcan.c
index 4dfa459ef5c7..95fefb1eef36 100644
--- a/drivers/net/can/slcan.c
+++ b/drivers/net/can/slcan.c
@@ -519,6 +519,7 @@ static struct slcan *slc_alloc(void)
 	int i;
 	char name[IFNAMSIZ];
 	struct net_device *dev = NULL;
+	struct can_ml_priv *can_ml;
 	struct slcan       *sl;
 	int size;
 
@@ -541,7 +542,8 @@ static struct slcan *slc_alloc(void)
 
 	dev->base_addr  = i;
 	sl = netdev_priv(dev);
-	dev->ml_priv = (void *)sl + ALIGN(sizeof(*sl), NETDEV_ALIGN);
+	can_ml = (void *)sl + ALIGN(sizeof(*sl), NETDEV_ALIGN);
+	can_set_ml_priv(dev, can_ml);
 
 	/* Initialize channel control data */
 	sl->magic = SLCAN_MAGIC;
diff --git a/drivers/net/can/softing/softing_main.c b/drivers/net/can/softing/softing_main.c
index 8242fb287cbb..16e3f55efa31 100644
--- a/drivers/net/can/softing/softing_main.c
+++ b/drivers/net/can/softing/softing_main.c
@@ -382,8 +382,13 @@ static int softing_netdev_open(struct net_device *ndev)
 
 	/* check or determine and set bittime */
 	ret = open_candev(ndev);
-	if (!ret)
-		ret = softing_startstop(ndev, 1);
+	if (ret)
+		return ret;
+
+	ret = softing_startstop(ndev, 1);
+	if (ret < 0)
+		close_candev(ndev);
+
 	return ret;
 }
 
diff --git a/drivers/net/can/spi/Kconfig b/drivers/net/can/spi/Kconfig
index 1c50788055cb..d4b68eb5d386 100644
--- a/drivers/net/can/spi/Kconfig
+++ b/drivers/net/can/spi/Kconfig
@@ -15,4 +15,6 @@ config CAN_MCP251X
 	  Driver for the Microchip MCP251x and MCP25625 SPI CAN
 	  controllers.
 
+source "drivers/net/can/spi/mcp25xxfd/Kconfig"
+
 endmenu
diff --git a/drivers/net/can/spi/Makefile b/drivers/net/can/spi/Makefile
index f115b2c46623..20c18ac96b1c 100644
--- a/drivers/net/can/spi/Makefile
+++ b/drivers/net/can/spi/Makefile
@@ -6,3 +6,4 @@
 
 obj-$(CONFIG_CAN_HI311X)	+= hi311x.o
 obj-$(CONFIG_CAN_MCP251X)	+= mcp251x.o
+obj-y				+= mcp25xxfd/
diff --git a/drivers/net/can/spi/mcp251x.c b/drivers/net/can/spi/mcp251x.c
index bb20a9b75cc6..b9df79bea60e 100644
--- a/drivers/net/can/spi/mcp251x.c
+++ b/drivers/net/can/spi/mcp251x.c
@@ -22,7 +22,6 @@
 #include <linux/can/core.h>
 #include <linux/can/dev.h>
 #include <linux/can/led.h>
-#include <linux/can/platform/mcp251x.h>
 #include <linux/clk.h>
 #include <linux/completion.h>
 #include <linux/delay.h>
@@ -33,6 +32,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/netdevice.h>
+#include <linux/of_gpio.h>
 #include <linux/property.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
@@ -220,11 +220,14 @@ struct mcp251x_priv {
 	int after_suspend;
 #define AFTER_SUSPEND_UP 1
 #define AFTER_SUSPEND_DOWN 2
-#define AFTER_SUSPEND_POWER 4
 #define AFTER_SUSPEND_RESTART 8
 	int restart_tx;
+	unsigned char sleeping;
+	unsigned char power_on;
 	struct regulator *power;
 	struct regulator *transceiver;
+	struct gpio_desc *transceiver_gpio;
+	struct gpio_desc *reset_gpio;
 	struct clk *clk;
 };
 
@@ -321,6 +324,18 @@ static void mcp251x_write_reg(struct spi_device *spi, u8 reg, u8 val)
 	mcp251x_spi_trans(spi, 3);
 }
 
+static void mcp251x_write_2regs(struct spi_device *spi, u8 reg, u8 v1, u8 v2)
+{
+	struct mcp251x_priv *priv = spi_get_drvdata(spi);
+
+	priv->spi_tx_buf[0] = INSTRUCTION_WRITE;
+	priv->spi_tx_buf[1] = reg;
+	priv->spi_tx_buf[2] = v1;
+	priv->spi_tx_buf[3] = v2;
+
+	mcp251x_spi_trans(spi, 4);
+}
+
 static void mcp251x_write_bits(struct spi_device *spi, u8 reg,
 			       u8 mask, u8 val)
 {
@@ -454,7 +469,45 @@ static void mcp251x_hw_rx(struct spi_device *spi, int buf_idx)
 
 static void mcp251x_hw_sleep(struct spi_device *spi)
 {
+	struct mcp251x_priv *priv = spi_get_drvdata(spi);
+
 	mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_SLEEP);
+	priv->sleeping = 1;
+}
+
+/* May only be called when device is sleeping! */
+static int mcp251x_hw_wake(struct spi_device *spi)
+{
+	struct mcp251x_priv *priv = spi_get_drvdata(spi);
+	unsigned long timeout;
+
+	/* Force wakeup interrupt to wake device, but don't execute IST */
+	disable_irq(spi->irq);
+	mcp251x_write_2regs(spi, CANINTE, CANINTE_WAKIE, CANINTF_WAKIF);
+
+	/* Wait for oscillator startup timer after wake up */
+	mdelay(MCP251X_OST_DELAY_MS);
+
+	/* Put device into config mode */
+	mcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_CONF);
+	priv->sleeping = 0;
+
+	/* Wait for the device to enter config mode */
+	timeout = jiffies + HZ;
+	while ((mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK) !=
+			CANCTRL_REQOP_CONF) {
+		schedule();
+		if (time_after(jiffies, timeout)) {
+			dev_err(&spi->dev, "MCP251x didn't enter in config mode\n");
+			return -EBUSY;
+		}
+	}
+
+	/* Disable and clear pending interrupts */
+	mcp251x_write_2regs(spi, CANINTE, 0x00, 0x00);
+	enable_irq(spi->irq);
+
+	return 0;
 }
 
 static netdev_tx_t mcp251x_hard_start_xmit(struct sk_buff *skb,
@@ -529,6 +582,7 @@ static int mcp251x_set_normal_mode(struct spi_device *spi)
 			}
 		}
 	}
+	priv->sleeping = 0;
 	priv->can.state = CAN_STATE_ERROR_ACTIVE;
 	return 0;
 }
@@ -581,6 +635,7 @@ static int mcp251x_hw_reset(struct spi_device *spi)
 	if (ret)
 		return ret;
 
+	priv->sleeping = 0;
 	/* Wait for oscillator startup timer after reset */
 	mdelay(MCP251X_OST_DELAY_MS);
 
@@ -631,6 +686,27 @@ static int mcp251x_power_enable(struct regulator *reg, int enable)
 		return regulator_disable(reg);
 }
 
+static int mcp251x_transceiver_enable(struct mcp251x_priv *priv, int enable)
+{
+	int ret;
+
+	ret = mcp251x_power_enable(priv->transceiver, enable);
+	gpiod_set_value_cansleep(priv->transceiver_gpio, enable);
+	return ret;
+}
+
+static int mcp251x_can_enable(struct mcp251x_priv *priv, int enable)
+{
+	int ret;
+
+	ret = mcp251x_power_enable(priv->power, enable);
+	gpiod_set_value_cansleep(priv->reset_gpio, enable ^ 1);
+	priv->power_on = enable;
+	if (!enable)
+		priv->sleeping = 0;
+	return ret;
+}
+
 static int mcp251x_stop(struct net_device *net)
 {
 	struct mcp251x_priv *priv = netdev_priv(net);
@@ -646,15 +722,14 @@ static int mcp251x_stop(struct net_device *net)
 	mutex_lock(&priv->mcp_lock);
 
 	/* Disable and clear pending interrupts */
-	mcp251x_write_reg(spi, CANINTE, 0x00);
-	mcp251x_write_reg(spi, CANINTF, 0x00);
+	mcp251x_write_2regs(spi, CANINTE, 0x00, 0x00);
 
 	mcp251x_write_reg(spi, TXBCTRL(0), 0);
 	mcp251x_clean(net);
 
 	mcp251x_hw_sleep(spi);
 
-	mcp251x_power_enable(priv->transceiver, 0);
+	mcp251x_transceiver_enable(priv, 0);
 
 	priv->can.state = CAN_STATE_STOPPED;
 
@@ -714,9 +789,13 @@ static void mcp251x_restart_work_handler(struct work_struct *ws)
 	struct net_device *net = priv->net;
 
 	mutex_lock(&priv->mcp_lock);
-	if (priv->after_suspend) {
+	if (!priv->sleeping) {
 		mcp251x_hw_reset(spi);
 		mcp251x_setup(net, spi);
+	} else {
+		mcp251x_hw_wake(spi);
+	}
+	if (priv->after_suspend) {
 		priv->force_quit = 0;
 		if (priv->after_suspend & AFTER_SUSPEND_RESTART) {
 			mcp251x_set_normal_mode(spi);
@@ -751,13 +830,14 @@ static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
 	while (!priv->force_quit) {
 		enum can_state new_state;
 		u8 intf, eflag;
-		u8 clear_intf = 0;
+		u8 clear_intf;
 		int can_id = 0, data1 = 0;
 
 		mcp251x_read_2regs(spi, CANINTF, &intf, &eflag);
 
 		/* mask out flags we don't care about */
 		intf &= CANINTF_RX | CANINTF_TX | CANINTF_ERR;
+		clear_intf = intf;
 
 		/* receive buffer 0 */
 		if (intf & CANINTF_RX0IF) {
@@ -768,19 +848,18 @@ static irqreturn_t mcp251x_can_ist(int irq, void *dev_id)
 			if (mcp251x_is_2510(spi))
 				mcp251x_write_bits(spi, CANINTF,
 						   CANINTF_RX0IF, 0x00);
+			clear_intf &= ~CANINTF_RX0IF;
 		}
 
 		/* receive buffer 1 */
 		if (intf & CANINTF_RX1IF) {
 			mcp251x_hw_rx(spi, 1);
 			/* The MCP2515/25625 does this automatically. */
-			if (mcp251x_is_2510(spi))
-				clear_intf |= CANINTF_RX1IF;
+			if (!mcp251x_is_2510(spi))
+				clear_intf &= ~CANINTF_RX1IF;
 		}
 
 		/* any error or tx interrupt we need to clear? */
-		if (intf & (CANINTF_ERR | CANINTF_TX))
-			clear_intf |= intf & (CANINTF_ERR | CANINTF_TX);
 		if (clear_intf)
 			mcp251x_write_bits(spi, CANINTF, clear_intf, 0x00);
 
@@ -887,7 +966,7 @@ static int mcp251x_open(struct net_device *net)
 	}
 
 	mutex_lock(&priv->mcp_lock);
-	mcp251x_power_enable(priv->transceiver, 1);
+	mcp251x_transceiver_enable(priv, 1);
 
 	priv->force_quit = 0;
 	priv->tx_skb = NULL;
@@ -913,7 +992,7 @@ static int mcp251x_open(struct net_device *net)
 	INIT_WORK(&priv->tx_work, mcp251x_tx_work_handler);
 	INIT_WORK(&priv->restart_work, mcp251x_restart_work_handler);
 
-	ret = mcp251x_hw_reset(spi);
+	ret = (priv->sleeping) ? mcp251x_hw_wake(spi) : mcp251x_hw_reset(spi);
 	if (ret)
 		goto out_free_wq;
 	ret = mcp251x_setup(net, spi);
@@ -936,7 +1015,7 @@ static int mcp251x_open(struct net_device *net)
 	free_irq(spi->irq, priv);
 	mcp251x_hw_sleep(spi);
 out_close:
-	mcp251x_power_enable(priv->transceiver, 0);
+	mcp251x_transceiver_enable(priv, 0);
 	close_candev(net);
 	mutex_unlock(&priv->mcp_lock);
 	return ret;
@@ -986,19 +1065,20 @@ MODULE_DEVICE_TABLE(spi, mcp251x_id_table);
 static int mcp251x_can_probe(struct spi_device *spi)
 {
 	const void *match = device_get_match_data(&spi->dev);
-	struct mcp251x_platform_data *pdata = dev_get_platdata(&spi->dev);
 	struct net_device *net;
 	struct mcp251x_priv *priv;
+	struct gpio_desc *gpio;
 	struct clk *clk;
-	int freq, ret;
+	u32 freq;
+	int ret;
 
 	clk = devm_clk_get_optional(&spi->dev, NULL);
 	if (IS_ERR(clk))
 		return PTR_ERR(clk);
 
 	freq = clk_get_rate(clk);
-	if (freq == 0 && pdata)
-		freq = pdata->oscillator_frequency;
+	if (freq == 0)
+		device_property_read_u32(&spi->dev, "clock-frequency", &freq);
 
 	/* Sanity check */
 	if (freq < 1000000 || freq > 25000000)
@@ -1048,8 +1128,17 @@ static int mcp251x_can_probe(struct spi_device *spi)
 		ret = -EPROBE_DEFER;
 		goto out_clk;
 	}
+	gpio = devm_gpiod_get_optional(&spi->dev, "xceiver", GPIOD_OUT_LOW);
+	if (IS_ERR(gpio))
+		return PTR_ERR(gpio);
+	priv->transceiver_gpio = gpio;
+
+	gpio = devm_gpiod_get_optional(&spi->dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(gpio))
+		return PTR_ERR(gpio);
+	priv->reset_gpio = gpio;
 
-	ret = mcp251x_power_enable(priv->power, 1);
+	ret = mcp251x_can_enable(priv, 1);
 	if (ret)
 		goto out_clk;
 
@@ -1093,7 +1182,7 @@ static int mcp251x_can_probe(struct spi_device *spi)
 	return 0;
 
 error_probe:
-	mcp251x_power_enable(priv->power, 0);
+	mcp251x_can_enable(priv, 0);
 
 out_clk:
 	clk_disable_unprepare(clk);
@@ -1112,7 +1201,7 @@ static int mcp251x_can_remove(struct spi_device *spi)
 
 	unregister_candev(net);
 
-	mcp251x_power_enable(priv->power, 0);
+	mcp251x_can_enable(priv, 0);
 
 	clk_disable_unprepare(priv->clk);
 
@@ -1136,14 +1225,13 @@ static int __maybe_unused mcp251x_can_suspend(struct device *dev)
 		netif_device_detach(net);
 
 		mcp251x_hw_sleep(spi);
-		mcp251x_power_enable(priv->transceiver, 0);
+		mcp251x_transceiver_enable(priv, 0);
 		priv->after_suspend = AFTER_SUSPEND_UP;
 	} else {
 		priv->after_suspend = AFTER_SUSPEND_DOWN;
 	}
 
-	mcp251x_power_enable(priv->power, 0);
-	priv->after_suspend |= AFTER_SUSPEND_POWER;
+	mcp251x_can_enable(priv, 0);
 
 	return 0;
 }
@@ -1153,15 +1241,15 @@ static int __maybe_unused mcp251x_can_resume(struct device *dev)
 	struct spi_device *spi = to_spi_device(dev);
 	struct mcp251x_priv *priv = spi_get_drvdata(spi);
 
-	if (priv->after_suspend & AFTER_SUSPEND_POWER)
-		mcp251x_power_enable(priv->power, 1);
+	if (!priv->power_on)
+		mcp251x_can_enable(priv, 1);
+	if (priv->after_suspend & AFTER_SUSPEND_UP)
+		mcp251x_transceiver_enable(priv, 1);
 
-	if (priv->after_suspend & AFTER_SUSPEND_UP) {
-		mcp251x_power_enable(priv->transceiver, 1);
+	if (priv->sleeping || (priv->after_suspend & AFTER_SUSPEND_UP))
 		queue_work(priv->wq, &priv->restart_work);
-	} else {
+	else
 		priv->after_suspend = 0;
-	}
 
 	priv->force_quit = 0;
 	enable_irq(spi->irq);
diff --git a/drivers/net/can/spi/mcp25xxfd/Kconfig b/drivers/net/can/spi/mcp25xxfd/Kconfig
new file mode 100644
index 000000000000..e5fbaf8e46e1
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/Kconfig
@@ -0,0 +1,25 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config CAN_MCP25XXFD
+	tristate "Microchip MCP25xxFD SPI CAN controllers"
+	help
+	  Driver for the Microchip MCP25XXFD SPI FD-CAN controller
+	  family.
+
+config CAN_MCP25XXFD_SANITY
+	depends on CAN_MCP25XXFD
+	bool "Additional Sanity Checks"
+	help
+	  This option enables additional sanity checks in the driver,
+	  that compares various internal counters with the in chip
+	  variants. This comes with a runtime overhead.
+	  Disable if unsure.
+
+config CAN_MCP25XXFD_LOG
+	depends on CAN_MCP25XXFD
+	bool "Logging"
+	help
+	  This option enables logging of events in the driver, that
+	  help debugging. This comes with a very small runtime
+	  overhead.
+	  Disable if unsure.
diff --git a/drivers/net/can/spi/mcp25xxfd/Makefile b/drivers/net/can/spi/mcp25xxfd/Makefile
new file mode 100644
index 000000000000..9a22a1a73954
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/Makefile
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+obj-$(CONFIG_CAN_MCP25XXFD) += mcp25xxfd.o
+
+mcp25xxfd-objs :=
+mcp25xxfd-objs += mcp25xxfd-core.o
+mcp25xxfd-objs += mcp25xxfd-crc16.o
+mcp25xxfd-objs += mcp25xxfd-dump.o
+mcp25xxfd-objs += mcp25xxfd-regmap.o
+
+mcp25xxfd-$(CONFIG_CAN_MCP25XXFD_LOG) += mcp25xxfd-log.o
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c
new file mode 100644
index 000000000000..8d2adbb6cc1b
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-core.c
@@ -0,0 +1,2311 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+//
+// Copyright (c) 2019, 2020 Pengutronix,
+//                          Marc Kleine-Budde <kernel@pengutronix.de>
+//
+// Based on:
+//
+// CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+//
+// Copyright (c) 2019 Martin Sperl <kernel@martin.sperl.org>
+//
+
+#include <linux/bitfield.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pm_runtime.h>
+
+#include <asm/unaligned.h>
+
+#include "mcp25xxfd.h"
+
+#define DEVICE_NAME "mcp25xxfd"
+
+#define MCP25XXFD_SYSCLOCK_HZ_MAX 40000000
+#define MCP25XXFD_SYSCLOCK_HZ_MIN 1000000
+#define MCP25XXFD_SPICLOCK_HZ_MAX 20000000
+#define MCP25XXFD_OSC_PLL_MULTIPLIER 10
+#define MCP25XXFD_OSC_DELAY_MS 3
+
+/* DS80000792B - MCP2517FD Errata
+ *
+ * Incorrect CRC for certain READ_CRC commands
+ *
+ * It is possible that there is a mismatch between the transmitted CRC
+ * and the actual CRC for the transmitted data when data is updated at
+ * a specific time during the SPI READ_CRC command. In these cases the
+ * transmitted CRC is wrong. The data transmitted is correct.
+ *
+ * Fix/Work Around:
+ *
+ * If a CRC mismatch occurs, reissue the READ_CRC command. Only bits
+ * 7/15/23/31 of the following registers can be affected:
+ *
+ * - CiTXIF		(*)
+ * - CiRXIF		(*)
+ * - CiCON
+ * - CiTBC
+ * - CiINT
+ * - CiRXOVIF		(*)
+ * - CiTXATIF		(*)
+ * - CiTXREQ		(*)
+ * - CiTREC
+ * - CiBDIAG0
+ * - CiBDIAG1
+ * - CiTXQSTA
+ * - CiFIFOSTAm
+ *
+ * The occurrence can be minimized by not using FIFOs 7/15/23/31. In
+ * these cases, the registers CiTXIF, CiRXIF, CiRXOVIF, CiTXATIF and
+ * CiTXREQ are not affected.
+ *
+ * Bit 31 of RAM reads with CRC could also be affected. This can be
+ * avoided by reading from a received FIFO only after the message has
+ * been loaded into the FIFO, indicated by the receive flags. This is
+ * the recommended procedure independent of the issue described here.
+ */
+
+static const struct can_bittiming_const mcp25xxfd_bittiming_const = {
+	.name = DEVICE_NAME,
+	.tseg1_min = 2,
+	.tseg1_max = 256,
+	.tseg2_min = 1,
+	.tseg2_max = 128,
+	.sjw_max = 128,
+	.brp_min = 1,
+	.brp_max = 256,
+	.brp_inc = 1,
+};
+
+static const struct can_bittiming_const mcp25xxfd_data_bittiming_const = {
+	.name = DEVICE_NAME,
+	.tseg1_min = 1,
+	.tseg1_max = 32,
+	.tseg2_min = 1,
+	.tseg2_max = 16,
+	.sjw_max = 16,
+	.brp_min = 1,
+	.brp_max = 256,
+	.brp_inc = 1,
+};
+
+static const char *mcp25xxfd_get_mode_str(const u8 mode)
+{
+	switch (mode) {
+	case MCP25XXFD_CAN_CON_MODE_MIXED:
+		return "Mixed (CAN FD/CAN 2.0)"; break;
+	case MCP25XXFD_CAN_CON_MODE_SLEEP:
+		return "Sleep"; break;
+	case MCP25XXFD_CAN_CON_MODE_INT_LOOPBACK:
+		return "Internal Loopback"; break;
+	case MCP25XXFD_CAN_CON_MODE_LISTENONLY:
+		return "Listen Only"; break;
+	case MCP25XXFD_CAN_CON_MODE_CONFIG:
+		return "Configuration"; break;
+	case MCP25XXFD_CAN_CON_MODE_EXT_LOOPBACK:
+		return "External Loopback"; break;
+	case MCP25XXFD_CAN_CON_MODE_CAN2_0:
+		return "CAN 2.0"; break;
+	case MCP25XXFD_CAN_CON_MODE_RESTRICTED:
+		return "Restricted Operation"; break;
+	}
+
+	return "<unknown>";
+}
+
+static inline int mcp25xxfd_vdd_enable(const struct mcp25xxfd_priv *priv)
+{
+	if (!priv->reg_vdd)
+		return 0;
+
+	return regulator_enable(priv->reg_vdd);
+}
+
+static inline int mcp25xxfd_vdd_disable(const struct mcp25xxfd_priv *priv)
+{
+	if (!priv->reg_vdd)
+		return 0;
+
+	return regulator_disable(priv->reg_vdd);
+}
+
+static inline int
+mcp25xxfd_transceiver_enable(const struct mcp25xxfd_priv *priv)
+{
+	int ret = 0;
+
+	if (priv->reg_xceiver)
+		ret = regulator_enable(priv->reg_xceiver);
+	if (priv->gpiod_xceiver)
+		gpiod_set_value_cansleep(priv->gpiod_xceiver, 1);
+	return ret;
+}
+
+static inline int
+mcp25xxfd_transceiver_disable(const struct mcp25xxfd_priv *priv)
+{
+	int ret = 0;
+
+	if (priv->gpiod_xceiver)
+		gpiod_set_value_cansleep(priv->gpiod_xceiver, 0);
+	if (priv->reg_xceiver)
+		ret = regulator_disable(priv->reg_xceiver);
+	return ret;
+}
+
+static int mcp25xxfd_clks_and_vdd_enable(const struct mcp25xxfd_priv *priv)
+{
+	int err;
+
+	err = clk_prepare_enable(priv->clk);
+	if (err)
+		return err;
+
+	err = mcp25xxfd_vdd_enable(priv);
+	if (err)
+		clk_disable_unprepare(priv->clk);
+
+	return err;
+}
+
+static int mcp25xxfd_clks_and_vdd_disable(const struct mcp25xxfd_priv *priv)
+{
+	int err;
+
+	err = mcp25xxfd_vdd_disable(priv);
+	if (err)
+		return err;
+
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static inline int
+mcp25xxfd_cmd_prepare_write(struct mcp25xxfd_reg_write_buf *write_reg_buf,
+			    const u16 reg, const u32 mask, const u32 val)
+{
+	u8 first_byte, last_byte, len;
+	__le32 val_le32;
+
+	first_byte = mcp25xxfd_first_byte_set(mask);
+	last_byte = mcp25xxfd_last_byte_set(mask);
+	len = last_byte - first_byte + 1;
+
+	write_reg_buf->cmd = mcp25xxfd_cmd_write(reg + first_byte);
+	val_le32 = cpu_to_le32(val >> 8 * first_byte);
+	memcpy(write_reg_buf->data, &val_le32, len);
+
+	return sizeof(write_reg_buf->cmd) + len;
+}
+
+static inline int
+mcp25xxfd_tef_obj_tail_get_rel_addr_from_chip(const struct mcp25xxfd_priv *priv,
+					      u16 *tef_obj_tail_rel_addr)
+{
+	int err;
+	u32 tef_ua;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_TEFUA, &tef_ua);
+	if (err)
+		return err;
+
+	*tef_obj_tail_rel_addr = tef_ua;
+
+	return 0;
+}
+
+static inline int
+mcp25xxfd_tef_tail_get_from_chip(const struct mcp25xxfd_priv *priv,
+				 u8 *tef_tail)
+{
+	int err;
+	u16 tef_obj_tail_rel_addr;
+
+	err = mcp25xxfd_tef_obj_tail_get_rel_addr_from_chip(priv,
+							    &tef_obj_tail_rel_addr);
+	if (err)
+		return err;
+
+	*tef_tail = tef_obj_tail_rel_addr / sizeof(struct mcp25xxfd_hw_tef_obj);
+
+	return 0;
+}
+
+static inline int
+mcp25xxfd_rx_obj_tail_get_rel_addr_from_chip(const struct mcp25xxfd_priv *priv,
+					     u16 *rx_obj_tail_rel_addr)
+{
+	int err;
+	u32 fifo_ua;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_FIFOUA(MCP25XXFD_RX_FIFO(0)),
+			  &fifo_ua);
+	if (err)
+		return err;
+
+	*rx_obj_tail_rel_addr = fifo_ua;
+
+	return 0;
+}
+
+static inline int
+mcp25xxfd_rx_tail_get_from_chip(const struct mcp25xxfd_priv *priv, u8 *rx_tail)
+{
+	int err;
+	u16 rx_obj_tail_rel_addr;
+
+	err = mcp25xxfd_rx_obj_tail_get_rel_addr_from_chip(priv,
+							   &rx_obj_tail_rel_addr);
+	if (err)
+		return err;
+
+	rx_obj_tail_rel_addr -= (sizeof(struct mcp25xxfd_hw_tef_obj) +
+				 priv->tx.obj_size) * priv->tx.obj_num;
+	*rx_tail = rx_obj_tail_rel_addr / priv->rx.obj_size;
+
+	return 0;
+}
+
+static void
+mcp25xxfd_tx_ring_init_one(const struct mcp25xxfd_priv *priv,
+			   struct mcp25xxfd_tx_obj *tx_obj, const u8 n)
+{
+	u32 val;
+	u16 addr;
+	u8 len;
+
+	/* FIFO load */
+	addr = mcp25xxfd_get_tx_obj_addr(priv, n);
+	tx_obj->load.buf.cmd = mcp25xxfd_cmd_write(addr);
+	/* len is calculated on the fly */
+
+	spi_message_init_with_transfers(&tx_obj->load.msg,
+					&tx_obj->load.xfer, 1);
+	tx_obj->load.xfer.tx_buf = &tx_obj->load.buf;
+	/* len is assigned on the fly */
+
+	/* FIFO trigger */
+	addr = MCP25XXFD_CAN_FIFOCON(MCP25XXFD_TX_FIFO);
+	val = MCP25XXFD_CAN_FIFOCON_TXREQ | MCP25XXFD_CAN_FIFOCON_UINC;
+	len = mcp25xxfd_cmd_prepare_write(&tx_obj->trigger.buf, addr, val, val);
+
+	spi_message_init_with_transfers(&tx_obj->trigger.msg,
+					&tx_obj->trigger.xfer, 1);
+	tx_obj->trigger.xfer.tx_buf = &tx_obj->trigger.buf;
+	tx_obj->trigger.xfer.len = len;
+}
+
+static void mcp25xxfd_ring_init(struct mcp25xxfd_priv *priv)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(priv->tx.obj); i++) {
+		struct mcp25xxfd_tx_obj *tx_obj = &priv->tx.obj[i];
+
+		mcp25xxfd_tx_ring_init_one(priv, tx_obj, i);
+	}
+
+	priv->tef.head = 0;
+	priv->tef.tail = 0;
+	priv->tx.head = 0;
+	priv->tx.tail = 0;
+	priv->rx.head = 0;
+	priv->rx.tail = 0;
+}
+
+static inline int
+mcp25xxfd_chip_get_mode(const struct mcp25xxfd_priv *priv, u8 *mode)
+{
+	u32 val;
+	int err;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_CON, &val);
+	if (err)
+		return err;
+
+	*mode = FIELD_GET(MCP25XXFD_CAN_CON_OPMOD_MASK, val);
+
+	return 0;
+}
+
+static int
+__mcp25xxfd_chip_set_mode(const struct mcp25xxfd_priv *priv,
+			  const u8 mode_req, bool nowait)
+{
+	u32 con, con_reqop;
+	int err;
+
+	con_reqop = FIELD_PREP(MCP25XXFD_CAN_CON_REQOP_MASK, mode_req);
+	err = regmap_update_bits(priv->map, MCP25XXFD_CAN_CON,
+				 MCP25XXFD_CAN_CON_REQOP_MASK, con_reqop);
+	if (err)
+		return err;
+
+	if (mode_req == MCP25XXFD_CAN_CON_MODE_SLEEP || nowait)
+		return 0;
+
+	err = regmap_read_poll_timeout(priv->map, MCP25XXFD_CAN_CON, con,
+				       FIELD_GET(MCP25XXFD_CAN_CON_OPMOD_MASK,
+						 con) == mode_req,
+				       10000, 1000000);
+	if (err) {
+		u8 mode = FIELD_GET(MCP25XXFD_CAN_CON_OPMOD_MASK, con);
+
+		netdev_err(priv->ndev,
+			   "Controller failed to enter mode %s Mode (%u) and stays in %s Mode (%u).\n",
+			   mcp25xxfd_get_mode_str(mode_req), mode_req,
+			   mcp25xxfd_get_mode_str(mode), mode);
+		return err;
+	}
+
+	return 0;
+}
+
+static inline int
+mcp25xxfd_chip_set_mode(const struct mcp25xxfd_priv *priv,
+			const u8 mode_req)
+{
+	return __mcp25xxfd_chip_set_mode(priv, mode_req, false);
+}
+
+static inline int
+mcp25xxfd_chip_set_mode_nowait(const struct mcp25xxfd_priv *priv,
+			       const u8 mode_req)
+{
+	return __mcp25xxfd_chip_set_mode(priv, mode_req, true);
+}
+
+static int mcp25xxfd_chip_clock_enable(const struct mcp25xxfd_priv *priv)
+{
+	u32 osc, osc_reference, osc_mask;
+	int err;
+
+	/* Set Power On Defaults for "Clock Output Divisor" and remove
+	 * "Oscillator Disable" bit.
+	 */
+	osc = FIELD_PREP(MCP25XXFD_OSC_CLKODIV_MASK, MCP25XXFD_OSC_CLKODIV_10);
+	osc_reference = MCP25XXFD_OSC_OSCRDY;
+	osc_mask = MCP25XXFD_OSC_OSCRDY | MCP25XXFD_OSC_PLLRDY;
+
+	/* Note:
+	 *
+	 * If the controller is in Sleep Mode the following write only
+	 * removes the "Oscillator Disable" bit and powers it up. All
+	 * other bits are unaffected.
+	 */
+	err = regmap_write(priv->map, MCP25XXFD_OSC, osc);
+	if (err)
+		return err;
+
+	/* Wait for "Oscillator Ready" bit */
+	return regmap_read_poll_timeout(priv->map, MCP25XXFD_OSC, osc,
+					(osc & osc_mask) == osc_reference,
+					10000, 1000000);
+}
+
+static int mcp25xxfd_chip_clock_init(const struct mcp25xxfd_priv *priv)
+{
+	u32 osc;
+	int err;
+
+	/* Activate Low Power Mode on Oscillator Disable. This only
+	 * works on the MCP2518FD. The MCP2517FD will go into normal
+	 * Sleep Mode instead.
+	 */
+	osc = MCP25XXFD_OSC_LPMEN |
+		FIELD_PREP(MCP25XXFD_OSC_CLKODIV_MASK,
+			   MCP25XXFD_OSC_CLKODIV_10);
+	err = regmap_write(priv->map, MCP25XXFD_OSC, osc);
+	if (err)
+		return err;
+
+	/* Set Time Base Counter Prescaler to 1.
+	 *
+	 * This means an overflow of the 32 bit Time Base Counter
+	 * register at 40 MHz every 107 seconds.
+	 */
+	return regmap_write(priv->map, MCP25XXFD_CAN_TSCON,
+			    MCP25XXFD_CAN_TSCON_TBCEN);
+}
+
+static int mcp25xxfd_chip_softreset(const struct mcp25xxfd_priv *priv)
+{
+	const __be16 cmd = mcp25xxfd_cmd_reset();
+	u8 mode;
+	int err;
+
+	/* The Set Mode and SPI Reset command only seems to works if
+	 * the controller is not in Sleep Mode.
+	 */
+	err = mcp25xxfd_chip_clock_enable(priv);
+	if (err)
+		return err;
+
+	err = mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_CONFIG);
+	if (err)
+		return err;
+
+	/* spi_write_then_read() works with non DMA-safe buffers */
+	err = spi_write_then_read(priv->spi, &cmd, sizeof(cmd), NULL, 0);
+	if (err)
+		return err;
+
+	err = mcp25xxfd_chip_get_mode(priv, &mode);
+	if (err)
+		return err;
+
+	if (mode != MCP25XXFD_CAN_CON_MODE_CONFIG) {
+		netdev_err(priv->ndev,
+			   "Controller not in Config Mode after reset, but in %s Mode (%u).\n",
+			   mcp25xxfd_get_mode_str(mode), mode);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_set_bittiming(const struct mcp25xxfd_priv *priv)
+{
+	const struct can_bittiming *bt = &priv->can.bittiming;
+	const struct can_bittiming *dbt = &priv->can.data_bittiming;
+	u32 val = 0;
+	s8 tdco;
+	int err;
+
+	/* CAN Control Register
+	 *
+	 * - no transmit bandwidth sharing
+	 * - config mode
+	 * - disable transmit queue
+	 * - store in transmit FIFO event
+	 * - transition to restricted operation mode on system error
+	 * - ESI is transmitted recessive when ESI of message is high or
+	 *   CAN controller error passive
+	 * - restricted retransmission attempts,
+	 *   use TQXCON_TXAT and FIFOCON_TXAT
+	 * - wake-up filter bits T11FILTER
+	 * - use CAN bus line filter for wakeup
+	 * - protocol exception is treated as a form error
+	 * - Do not compare data bytes
+	 */
+	val = FIELD_PREP(MCP25XXFD_CAN_CON_REQOP_MASK,
+			 MCP25XXFD_CAN_CON_MODE_CONFIG) |
+		MCP25XXFD_CAN_CON_STEF |
+		MCP25XXFD_CAN_CON_ESIGM |
+		MCP25XXFD_CAN_CON_RTXAT |
+		FIELD_PREP(MCP25XXFD_CAN_CON_WFT_MASK,
+			   MCP25XXFD_CAN_CON_WFT_T11FILTER) |
+		MCP25XXFD_CAN_CON_WAKFIL |
+		MCP25XXFD_CAN_CON_PXEDIS;
+
+	if (!(priv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO))
+		val |= MCP25XXFD_CAN_CON_ISOCRCEN;
+
+	err = regmap_write(priv->map, MCP25XXFD_CAN_CON, val);
+	if (err)
+		return err;
+
+	/* Nominal Bit Time */
+	val = FIELD_PREP(MCP25XXFD_CAN_NBTCFG_BRP_MASK, bt->brp - 1) |
+		FIELD_PREP(MCP25XXFD_CAN_NBTCFG_TSEG1_MASK,
+			   bt->prop_seg + bt->phase_seg1 - 1) |
+		FIELD_PREP(MCP25XXFD_CAN_NBTCFG_TSEG2_MASK,
+			   bt->phase_seg2 - 1) |
+		FIELD_PREP(MCP25XXFD_CAN_NBTCFG_SJW_MASK, bt->sjw - 1);
+
+	err = regmap_write(priv->map, MCP25XXFD_CAN_NBTCFG, val);
+	if (err)
+		return err;
+
+	if (!(priv->can.ctrlmode & CAN_CTRLMODE_FD))
+		return 0;
+
+	/* Data Bit Time */
+	val = FIELD_PREP(MCP25XXFD_CAN_DBTCFG_BRP_MASK, dbt->brp - 1) |
+		FIELD_PREP(MCP25XXFD_CAN_DBTCFG_TSEG1_MASK,
+			   dbt->prop_seg + dbt->phase_seg1 - 1) |
+		FIELD_PREP(MCP25XXFD_CAN_DBTCFG_TSEG2_MASK,
+			   dbt->phase_seg2 - 1) |
+		FIELD_PREP(MCP25XXFD_CAN_DBTCFG_SJW_MASK, dbt->sjw - 1);
+
+	err = regmap_write(priv->map, MCP25XXFD_CAN_DBTCFG, val);
+	if (err)
+		return err;
+
+	/* Transmitter Delay Compensation */
+	tdco = clamp_t(int, dbt->brp * (dbt->prop_seg + dbt->phase_seg1),
+		       -64, 63);
+	val = FIELD_PREP(MCP25XXFD_CAN_TDC_TDCMOD_MASK,
+			 MCP25XXFD_CAN_TDC_TDCMOD_AUTO) |
+		FIELD_PREP(MCP25XXFD_CAN_TDC_TDCO_MASK, tdco);
+
+	return regmap_write(priv->map, MCP25XXFD_CAN_TDC, val);
+}
+
+static int mcp25xxfd_chip_pinctrl_init(const struct mcp25xxfd_priv *priv)
+{
+	u32 val;
+
+	if (!priv->rx_int)
+		return 0;
+
+	/* Configure GPIOs:
+	 * - PIN0: GPIO Input
+	 * - PIN1: RX Interrupt
+	 */
+	val = MCP25XXFD_IOCON_PM0 | MCP25XXFD_IOCON_TRIS0;
+	return regmap_write(priv->map, MCP25XXFD_IOCON, val);
+}
+
+static int mcp25xxfd_chip_fifo_compute(struct mcp25xxfd_priv *priv)
+{
+	int tef_obj_size, tx_obj_size, rx_obj_size;
+	int tx_obj_num, rx_obj_num;
+	int ram_free;
+
+	tef_obj_size = sizeof(struct mcp25xxfd_hw_tef_obj);
+	if (priv->can.ctrlmode & CAN_CTRLMODE_FD) {
+		tx_obj_num = MCP25XXFD_TX_OBJ_NUM_CANFD;
+		tx_obj_size = sizeof(struct mcp25xxfd_hw_tx_obj_canfd);
+		rx_obj_size = sizeof(struct mcp25xxfd_hw_rx_obj_canfd);
+	} else {
+		tx_obj_num = MCP25XXFD_TX_OBJ_NUM_CAN;
+		tx_obj_size = sizeof(struct mcp25xxfd_hw_tx_obj_can);
+		rx_obj_size = sizeof(struct mcp25xxfd_hw_rx_obj_can);
+	}
+
+	ram_free = MCP25XXFD_RAM_SIZE - tx_obj_num *
+		(tef_obj_size + tx_obj_size);
+	rx_obj_num = min(ram_free / rx_obj_size, 32);
+	ram_free -= rx_obj_num * rx_obj_size;
+
+	if ((priv->can.ctrlmode & CAN_CTRLMODE_FD &&
+	     rx_obj_num > MCP25XXFD_RX_OBJ_NUM_CANFD) ||
+	    (!(priv->can.ctrlmode & CAN_CTRLMODE_FD) &&
+	     rx_obj_num > MCP25XXFD_RX_OBJ_NUM_CAN)) {
+		netdev_err(priv->ndev,
+			   "Too many rx-objects (calculated=%d, max=%d).\n",
+			   rx_obj_num, priv->can.ctrlmode & CAN_CTRLMODE_FD ?
+			   MCP25XXFD_RX_OBJ_NUM_CANFD :
+			   MCP25XXFD_RX_OBJ_NUM_CAN);
+		return -ENOMEM;
+	}
+
+	priv->tx.obj_num = tx_obj_num;
+	priv->tx.obj_size = tx_obj_size;
+	priv->rx.obj_num = rx_obj_num;
+	priv->rx.obj_size = rx_obj_size;
+
+	netdev_dbg(priv->ndev,
+		   "FIFO setup: tef: %d*%d bytes = %d bytes, tx: %d*%d bytes = %d, rx: %d*%d bytes = %d bytes, free: %d bytes.\n",
+		   tx_obj_num, tef_obj_size, tef_obj_size * tx_obj_num,
+		   tx_obj_num, tx_obj_size, tx_obj_size * tx_obj_num,
+		   rx_obj_num, rx_obj_size, rx_obj_size * rx_obj_num,
+		   ram_free);
+
+	return 0;
+}
+
+static int mcp25xxfd_chip_fifo_init(struct mcp25xxfd_priv *priv)
+{
+	u32 val;
+	int err;
+
+	err = mcp25xxfd_chip_fifo_compute(priv);
+	if (err)
+		return err;
+
+	mcp25xxfd_ring_init(priv);
+
+	/* TEF */
+	val = FIELD_PREP(MCP25XXFD_CAN_TEFCON_FSIZE_MASK,
+			 priv->tx.obj_num - 1) |
+		MCP25XXFD_CAN_TEFCON_TEFTSEN |
+		MCP25XXFD_CAN_TEFCON_TEFOVIE |
+		MCP25XXFD_CAN_TEFCON_TEFNEIE;
+
+	err = regmap_write(priv->map, MCP25XXFD_CAN_TEFCON, val);
+	if (err)
+		return err;
+
+	/* FIFO 1 - TX */
+	val = FIELD_PREP(MCP25XXFD_CAN_FIFOCON_FSIZE_MASK,
+			 priv->tx.obj_num - 1) |
+		MCP25XXFD_CAN_FIFOCON_TXEN |
+		MCP25XXFD_CAN_FIFOCON_TXATIE;
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_FD)
+		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK,
+				  MCP25XXFD_CAN_FIFOCON_PLSIZE_64);
+	else
+		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK,
+				  MCP25XXFD_CAN_FIFOCON_PLSIZE_8);
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)
+		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_TXAT_MASK,
+				  MCP25XXFD_CAN_FIFOCON_TXAT_ONE_SHOT);
+	else
+		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_TXAT_MASK,
+				  MCP25XXFD_CAN_FIFOCON_TXAT_UNLIMITED);
+
+	err = regmap_write(priv->map, MCP25XXFD_CAN_FIFOCON(MCP25XXFD_TX_FIFO),
+			   val);
+	if (err)
+		return err;
+
+	/* FIFO 2 - RX */
+	val = FIELD_PREP(MCP25XXFD_CAN_FIFOCON_FSIZE_MASK,
+			 priv->rx.obj_num - 1) |
+		MCP25XXFD_CAN_FIFOCON_RXTSEN |
+		MCP25XXFD_CAN_FIFOCON_RXOVIE |
+		MCP25XXFD_CAN_FIFOCON_TFNRFNIE;
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_FD)
+		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK,
+				  MCP25XXFD_CAN_FIFOCON_PLSIZE_64);
+	else
+		val |= FIELD_PREP(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK,
+				  MCP25XXFD_CAN_FIFOCON_PLSIZE_8);
+
+	err = regmap_write(priv->map,
+			   MCP25XXFD_CAN_FIFOCON(MCP25XXFD_RX_FIFO(0)), val);
+	if (err)
+		return err;
+
+	/* RX Filter */
+	val = MCP25XXFD_CAN_FLTCON_FLTEN0 |
+		FIELD_PREP(MCP25XXFD_CAN_FLTCON_F0BP_MASK,
+			   MCP25XXFD_RX_FIFO(0));
+	return regmap_write(priv->map, MCP25XXFD_CAN_FLTCON(0), val);
+}
+
+static int mcp25xxfd_chip_ecc_init(const struct mcp25xxfd_priv *priv)
+{
+	void *ram;
+	int err;
+
+	ram = kzalloc(MCP25XXFD_RAM_SIZE, GFP_KERNEL);
+	if (!ram)
+		return -ENOMEM;
+
+	err = regmap_raw_write(priv->map, MCP25XXFD_RAM_START, ram,
+			       MCP25XXFD_RAM_SIZE);
+	kfree(ram);
+
+	return err;
+}
+
+static u8 mcp25xxfd_get_normal_mode(const struct mcp25xxfd_priv *priv)
+{
+	u8 mode;
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_FD)
+		mode = MCP25XXFD_CAN_CON_MODE_MIXED;
+	else
+		mode = MCP25XXFD_CAN_CON_MODE_CAN2_0;
+
+	return mode;
+}
+
+static int
+__mcp25xxfd_chip_set_normal_mode(const struct mcp25xxfd_priv *priv,
+				 bool nowait)
+{
+	u8 mode;
+
+	mode = mcp25xxfd_get_normal_mode(priv);
+
+	return __mcp25xxfd_chip_set_mode(priv, mode, nowait);
+}
+
+static inline int
+mcp25xxfd_chip_set_normal_mode(const struct mcp25xxfd_priv *priv)
+{
+	return __mcp25xxfd_chip_set_normal_mode(priv, false);
+}
+
+static inline int
+mcp25xxfd_chip_set_normal_mode_nowait(const struct mcp25xxfd_priv *priv)
+{
+	return __mcp25xxfd_chip_set_normal_mode(priv, true);
+}
+
+static int mcp25xxfd_chip_interrupts_enable(const struct mcp25xxfd_priv *priv)
+{
+	u32 val;
+	int err;
+
+	val = MCP25XXFD_CAN_INT_CERRIE |
+		MCP25XXFD_CAN_INT_SERRIE |
+		MCP25XXFD_CAN_INT_RXOVIE |
+		MCP25XXFD_CAN_INT_TXATIE |
+		MCP25XXFD_CAN_INT_SPICRCIE |
+		MCP25XXFD_CAN_INT_ECCIE |
+		MCP25XXFD_CAN_INT_TEFIE |
+		MCP25XXFD_CAN_INT_MODIE |
+		MCP25XXFD_CAN_INT_RXIE;
+
+	if (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)
+		val |= MCP25XXFD_CAN_INT_IVMIE;
+
+	err = regmap_write(priv->map, MCP25XXFD_CAN_INT, val);
+	if (err)
+		return err;
+
+	val = MCP25XXFD_CRC_FERRIE |
+		MCP25XXFD_CRC_CRCERRIE;
+	err = regmap_write(priv->map, MCP25XXFD_CRC, val);
+	if (err)
+		return err;
+
+	val = MCP25XXFD_ECCCON_DEDIE |
+		MCP25XXFD_ECCCON_SECIE |
+		MCP25XXFD_ECCCON_ECCEN;
+	return regmap_write(priv->map, MCP25XXFD_ECCCON, val);
+}
+
+static int mcp25xxfd_chip_interrupts_disable(const struct mcp25xxfd_priv *priv)
+{
+	int err;
+
+	err = regmap_write(priv->map, MCP25XXFD_ECCCON, 0);
+	if (err)
+		return err;
+
+	err = regmap_write(priv->map, MCP25XXFD_CRC, 0);
+	if (err)
+		return err;
+
+	return regmap_write(priv->map, MCP25XXFD_CAN_INT, 0);
+}
+
+static int mcp25xxfd_chip_start(struct mcp25xxfd_priv *priv)
+{
+	int err;
+
+	err = mcp25xxfd_chip_softreset(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_chip_clock_init(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_set_bittiming(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_chip_pinctrl_init(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_chip_fifo_init(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_chip_ecc_init(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	/* Note:
+	 *
+	 * First enable the interrupts, then bring the chip into
+	 * Normal Mode. Otherwise on a MCP2517FD a burst of CAN
+	 * messages on the bus may result in overwritten RX FIFO
+	 * contents and ECC errors.
+	 *
+	 * The current theory is that the SPI read access disturbes
+	 * the RX process in the chip.
+	 */
+	priv->can.state = CAN_STATE_ERROR_ACTIVE;
+
+	err = mcp25xxfd_chip_interrupts_enable(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_chip_set_normal_mode(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	return 0;
+
+ out_chip_set_mode_sleep:
+	mcp25xxfd_chip_interrupts_disable(priv);
+	mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_SLEEP);
+	priv->can.state = CAN_STATE_STOPPED;
+
+	return err;
+}
+
+static int mcp25xxfd_chip_stop(struct mcp25xxfd_priv *priv,
+			       const enum can_state state)
+{
+	priv->can.state = state;
+
+	mcp25xxfd_chip_interrupts_disable(priv);
+	return mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_SLEEP);
+}
+
+static int mcp25xxfd_set_mode(struct net_device *ndev, enum can_mode mode)
+{
+	struct mcp25xxfd_priv *priv = netdev_priv(ndev);
+	int err;
+
+	switch (mode) {
+	case CAN_MODE_START:
+		err = mcp25xxfd_chip_start(priv);
+		if (err)
+			return err;
+
+		netif_wake_queue(ndev);
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_get_berr_counter(const struct net_device *ndev,
+				      struct can_berr_counter *bec)
+{
+	const struct mcp25xxfd_priv *priv = netdev_priv(ndev);
+	u32 trec;
+	int err;
+
+	/* Avoid waking up the controller when the interface is down. */
+	if (!(ndev->flags & IFF_UP))
+		return 0;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_TREC, &trec);
+	if (err)
+		return err;
+
+	bec->txerr = FIELD_GET(MCP25XXFD_CAN_TREC_TEC_MASK, trec);
+	bec->rxerr = FIELD_GET(MCP25XXFD_CAN_TREC_REC_MASK, trec);
+
+	return 0;
+}
+
+static int mcp25xxfd_check_tef_tail(struct mcp25xxfd_priv *priv)
+{
+	u8 tef_tail_chip, tef_tail;
+	int err;
+
+	if (!IS_ENABLED(CONFIG_CAN_MCP25XXFD_SANITY))
+		return 0;
+
+	err = mcp25xxfd_tef_tail_get_from_chip(priv, &tef_tail_chip);
+	if (err)
+		return err;
+
+	mcp25xxfd_log_hw_tef_tail(priv, tef_tail_chip);
+
+	tef_tail = mcp25xxfd_get_tef_tail(priv);
+	if (tef_tail_chip != tef_tail) {
+		netdev_err(priv->ndev,
+			   "TEF tail of chip (0x%02x) and ours (0x%08x) inconsistent.\n",
+			   tef_tail_chip, tef_tail);
+		return -EILSEQ;
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_check_rx_tail(const struct mcp25xxfd_priv *priv)
+{
+	u8 rx_tail_chip, rx_tail;
+	int err;
+
+	if (!IS_ENABLED(CONFIG_CAN_MCP25XXFD_SANITY))
+		return 0;
+
+	err = mcp25xxfd_rx_tail_get_from_chip(priv, &rx_tail_chip);
+	if (err)
+		return err;
+
+	rx_tail = mcp25xxfd_get_rx_tail(priv);
+	if (rx_tail_chip != rx_tail) {
+		netdev_err(priv->ndev,
+			   "RX tail of chip (%d) and ours (%d) inconsistent.\n",
+			   rx_tail_chip, rx_tail);
+		return -EILSEQ;
+	}
+
+	return 0;
+}
+
+static int
+mcp25xxfd_handle_tefif_recover(const struct mcp25xxfd_priv *priv, const u32 seq)
+{
+	u32 tef_sta;
+	int err;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_TEFSTA, &tef_sta);
+	if (err)
+		return err;
+
+	if (tef_sta & MCP25XXFD_CAN_TEFSTA_TEFOVIF) {
+		netdev_err(priv->ndev,
+			   "Transmit Event FIFO buffer overflow.\n");
+		return -ENOBUFS;
+	}
+
+	netdev_info(priv->ndev,
+		   "Transmit Event FIFO buffer %s (seq=0x%08x, tef_tail=0x%08x, tef_head=0x%08x, tx_head=0x%08x)\n",
+		   tef_sta & MCP25XXFD_CAN_TEFSTA_TEFNEIF ?
+		   "empty." : "not empty anymore?",
+		   seq, priv->tef.tail, priv->tef.head, priv->tx.head);
+
+	return -EAGAIN;
+}
+
+static int
+mcp25xxfd_handle_tefif_one(struct mcp25xxfd_priv *priv,
+			   const struct mcp25xxfd_hw_tef_obj *hw_tef_obj)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	u32 seq, seq_masked, tef_tail_masked;
+	int err;
+
+	seq = FIELD_GET(MCP25XXFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK,
+			hw_tef_obj->flags);
+
+	/* Use the MCP2517FD mask on the MCP2518FD, too. We only
+	 * compare 7 bits, this should be enough to detect
+	 * net-yet-completed, i.e. old TEF objects.
+	 */
+	seq_masked = seq &
+		field_mask(MCP25XXFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK);
+	tef_tail_masked = priv->tef.tail &
+		field_mask(MCP25XXFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK);
+	if (seq_masked != tef_tail_masked)
+		return mcp25xxfd_handle_tefif_recover(priv, seq);
+
+	mcp25xxfd_log(priv, hw_tef_obj->id);
+
+	stats->tx_bytes +=
+		can_rx_offload_get_echo_skb(&priv->offload,
+					    mcp25xxfd_get_tef_tail(priv),
+					    hw_tef_obj->ts);
+	stats->tx_packets++;
+
+	/* finally increment the TEF pointer */
+	err = regmap_update_bits(priv->map, MCP25XXFD_CAN_TEFCON,
+				 GENMASK(15, 8),
+				 MCP25XXFD_CAN_TEFCON_UINC);
+	if (err)
+		return err;
+
+	priv->tx.tail++;
+	priv->tef.tail++;
+
+	return mcp25xxfd_check_tef_tail(priv);
+}
+
+static int mcp25xxfd_tef_ring_update(struct mcp25xxfd_priv *priv)
+{
+	u32 fifo_sta, new_head;
+	u8 tx_ci;
+	int err;
+
+	/* guess head */
+	err = regmap_read(priv->map, MCP25XXFD_CAN_FIFOSTA(MCP25XXFD_TX_FIFO),
+			  &fifo_sta);
+	if (err)
+		return err;
+
+	tx_ci = FIELD_GET(MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK, fifo_sta);
+	new_head = round_down(priv->tef.head, priv->tx.obj_num) + tx_ci;
+
+	if (new_head <= priv->tef.head)
+		new_head += priv->tx.obj_num;
+
+	priv->tef.head = min(new_head, priv->tx.head);
+
+	mcp25xxfd_log_hw_tx_ci(priv, tx_ci);
+
+	return mcp25xxfd_check_tef_tail(priv);
+}
+
+static inline int
+mcp25xxfd_tef_obj_read(const struct mcp25xxfd_priv *priv,
+		       struct mcp25xxfd_hw_tef_obj *hw_tef_obj,
+		       const u8 offset, const u8 len)
+{
+	if (IS_ENABLED(CONFIG_CAN_MCP25XXFD_SANITY) &&
+	    (offset > priv->tx.obj_num ||
+	     len > priv->tx.obj_num ||
+	     offset + len > priv->tx.obj_num)) {
+		netdev_err(priv->ndev,
+			   "Trying to read to many TEF objects (max=%d, offset=%d, len=%d).\n",
+			   priv->tx.obj_num, offset, len);
+		return -ERANGE;
+	}
+
+	return regmap_bulk_read(priv->map,
+				mcp25xxfd_get_tef_obj_addr(priv, offset),
+				hw_tef_obj,
+				sizeof(*hw_tef_obj) / sizeof(u32) * len);
+}
+
+static int mcp25xxfd_handle_tefif(struct mcp25xxfd_priv *priv)
+{
+	struct mcp25xxfd_hw_tef_obj hw_tef_obj[MCP25XXFD_TX_OBJ_NUM_MAX];
+	u8 tef_tail, len, l;
+	int err, i;
+
+	err = mcp25xxfd_tef_ring_update(priv);
+	if (err)
+		return err;
+
+	tef_tail = mcp25xxfd_get_tef_tail(priv);
+	len = mcp25xxfd_get_tef_len(priv);
+	l = mcp25xxfd_get_tef_linear_len(priv);
+	err = mcp25xxfd_tef_obj_read(priv, hw_tef_obj, tef_tail, l);
+	if (err)
+		return err;
+
+	if (l < len) {
+		err = mcp25xxfd_tef_obj_read(priv, &hw_tef_obj[l], 0, len - l);
+		if (err)
+			return err;
+	}
+
+	for (i = 0; i < len; i++) {
+		err = mcp25xxfd_handle_tefif_one(priv, &hw_tef_obj[i]);
+		/* -EAGAIN means the Sequence Number in the TEF
+		 * doesn't match our tef_tail. This can happen if we
+		 * read the TEF objects too early. Leave loop let the
+		 * interrupt handler call us again.
+		 */
+		if (err == -EAGAIN)
+			goto out_netif_wake_queue;
+		if (err)
+			return err;
+	}
+
+ out_netif_wake_queue:
+	mcp25xxfd_log_wake(priv, hw_tef_obj->id);
+	netif_wake_queue(priv->ndev);
+
+	return 0;
+}
+
+static int mcp25xxfd_rx_ring_update(struct mcp25xxfd_priv *priv)
+{
+	u32 fifo_sta, new_head;
+	u8 rx_ci;
+	int err;
+
+	err = regmap_read(priv->map,
+			  MCP25XXFD_CAN_FIFOSTA(MCP25XXFD_RX_FIFO(0)),
+			  &fifo_sta);
+	if (err)
+		return err;
+
+	rx_ci = FIELD_GET(MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK, fifo_sta);
+	new_head = round_down(priv->rx.head, priv->rx.obj_num) + rx_ci;
+
+	if (new_head <= priv->rx.head)
+		new_head += priv->rx.obj_num;
+
+	priv->rx.head = new_head;
+
+	return mcp25xxfd_check_rx_tail(priv);
+}
+
+static void
+mcp25xxfd_hw_rx_obj_to_skb(const struct mcp25xxfd_priv *priv,
+			   const struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj,
+			   struct sk_buff *skb)
+{
+	struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
+
+	if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_IDE) {
+		u32 sid, eid;
+
+		eid = FIELD_GET(MCP25XXFD_OBJ_ID_EID_MASK, hw_rx_obj->id);
+		sid = FIELD_GET(MCP25XXFD_OBJ_ID_SID_MASK, hw_rx_obj->id);
+
+		cfd->can_id = CAN_EFF_FLAG |
+			FIELD_PREP(MCP25XXFD_CAN_FRAME_EFF_EID_MASK, eid) |
+			FIELD_PREP(MCP25XXFD_CAN_FRAME_EFF_SID_MASK, sid);
+	} else {
+		cfd->can_id = FIELD_GET(MCP25XXFD_OBJ_ID_SID_MASK,
+					hw_rx_obj->id);
+	}
+
+	/* CANFD */
+	if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_FDF) {
+		u8 dlc;
+
+		if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_ESI)
+			cfd->flags |= CANFD_ESI;
+
+		if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_BRS)
+			cfd->flags |= CANFD_BRS;
+
+		dlc = FIELD_GET(MCP25XXFD_OBJ_FLAGS_DLC, hw_rx_obj->flags);
+		cfd->len = can_dlc2len(get_canfd_dlc(dlc));
+	} else {
+		if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_RTR)
+			cfd->can_id |= CAN_RTR_FLAG;
+
+		cfd->len = get_can_dlc(FIELD_GET(MCP25XXFD_OBJ_FLAGS_DLC,
+						 hw_rx_obj->flags));
+	}
+
+	memcpy(cfd->data, hw_rx_obj->data, cfd->len);
+}
+
+static int
+mcp25xxfd_handle_rxif_one(struct mcp25xxfd_priv *priv,
+			  const struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	struct sk_buff *skb;
+	struct canfd_frame *cfd;
+	int err;
+
+	if (hw_rx_obj->flags & MCP25XXFD_OBJ_FLAGS_FDF)
+		skb = alloc_canfd_skb(priv->ndev, &cfd);
+	else
+		skb = alloc_can_skb(priv->ndev, (struct can_frame **)&cfd);
+
+	if (!cfd) {
+		stats->rx_dropped++;
+		return 0;
+	}
+
+	mcp25xxfd_hw_rx_obj_to_skb(priv, hw_rx_obj, skb);
+	err = can_rx_offload_queue_sorted(&priv->offload, skb, hw_rx_obj->ts);
+	if (err)
+		stats->rx_fifo_errors++;
+
+	priv->rx.tail++;
+
+	/* finally increment the RX pointer */
+	return regmap_update_bits(priv->map,
+				  MCP25XXFD_CAN_FIFOCON(MCP25XXFD_RX_FIFO(0)),
+				  GENMASK(15, 8),
+				  MCP25XXFD_CAN_FIFOCON_UINC);
+}
+
+static inline int
+mcp25xxfd_rx_obj_read(const struct mcp25xxfd_priv *priv,
+		      struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj,
+		      const u8 offset, const u8 len)
+{
+	return regmap_bulk_read(priv->map,
+				mcp25xxfd_get_rx_obj_addr(priv, offset),
+				hw_rx_obj,
+				len * priv->rx.obj_size / sizeof(u32));
+}
+
+static int mcp25xxfd_handle_rxif(struct mcp25xxfd_priv *priv)
+{
+	struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj = priv->rx.obj;
+	u8 rx_tail, len, l;
+	int err, i;
+
+	err = mcp25xxfd_rx_ring_update(priv);
+	if (err)
+		return err;
+
+	rx_tail = mcp25xxfd_get_rx_tail(priv);
+	len = mcp25xxfd_get_rx_len(priv);
+	l = mcp25xxfd_get_rx_linear_len(priv);
+	err = mcp25xxfd_rx_obj_read(priv, hw_rx_obj, rx_tail, l);
+	if (err)
+		return err;
+
+	if (l < len) {
+		err = mcp25xxfd_rx_obj_read(priv, (void *)hw_rx_obj +
+					    l * priv->rx.obj_size, 0, len - l);
+		if (err)
+			return err;
+	}
+
+	for (i = 0; i < len; i++) {
+		err = mcp25xxfd_handle_rxif_one(priv, (void *)hw_rx_obj +
+						i * priv->rx.obj_size);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static inline int mcp25xxfd_get_timestamp(const struct mcp25xxfd_priv *priv,
+					  u32 *timestamp)
+{
+	return regmap_read(priv->map, MCP25XXFD_CAN_TBC, timestamp);
+}
+
+static struct sk_buff *
+mcp25xxfd_alloc_can_err_skb(const struct mcp25xxfd_priv *priv,
+			    struct can_frame **cf, u32 *timestamp)
+{
+	int err;
+
+	err = mcp25xxfd_get_timestamp(priv, timestamp);
+	if (err)
+		return NULL;
+
+	return alloc_can_err_skb(priv->ndev, cf);
+}
+
+static int mcp25xxfd_handle_rxovif(struct mcp25xxfd_priv *priv)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	struct sk_buff *skb;
+	struct can_frame *cf;
+	u32 timestamp, rxovif;
+	int err, i;
+
+	stats->rx_over_errors++;
+	stats->rx_errors++;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_RXOVIF, &rxovif);
+	if (err)
+		return err;
+
+	for (i = 0; i < MCP25XXFD_RX_FIFO_NUM; i++) {
+		const u8 rx_fifo = MCP25XXFD_RX_FIFO(i);
+
+		if (rxovif & BIT(rx_fifo)) {
+			netdev_warn(priv->ndev,
+				   "RX-FIFO overflow in FIFO %d.\n", rx_fifo);
+
+			err = regmap_update_bits(priv->map,
+						 MCP25XXFD_CAN_FIFOSTA(rx_fifo),
+						 MCP25XXFD_CAN_FIFOSTA_RXOVIF,
+						 0x0);
+			if (err)
+				return err;
+		}
+	}
+
+	skb = mcp25xxfd_alloc_can_err_skb(priv, &cf, &timestamp);
+	if (!skb)
+		return 0;
+
+	cf->can_id |= CAN_ERR_CRTL;
+	cf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;
+
+	err = can_rx_offload_queue_sorted(&priv->offload, skb, timestamp);
+	if (err)
+		stats->rx_fifo_errors++;
+
+	return 0;
+}
+
+static int mcp25xxfd_handle_txatif(struct mcp25xxfd_priv *priv)
+{
+	netdev_info(priv->ndev, "%s\n", __func__);
+
+	return 0;
+}
+
+static int mcp25xxfd_handle_ivmif(struct mcp25xxfd_priv *priv)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	u32 bdiag1, timestamp;
+	struct sk_buff *skb;
+	struct can_frame *cf = NULL;
+	int err;
+
+	err = mcp25xxfd_get_timestamp(priv, &timestamp);
+	if (err)
+		return err;
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_BDIAG1, &bdiag1);
+	if (err)
+		return err;
+
+	/* Write 0s to clear error bits, don't write 1s to non active
+	 * bits, as they will be set.
+	 */
+	err = regmap_write(priv->map, MCP25XXFD_CAN_BDIAG1, 0x0);
+	if (err)
+		return err;
+
+	priv->can.can_stats.bus_error++;
+
+	skb = alloc_can_err_skb(priv->ndev, &cf);
+	if (cf)
+		cf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;
+
+	/* Controller misconfiguration */
+	if (WARN_ON(bdiag1 & MCP25XXFD_CAN_BDIAG1_DLCMM))
+		netdev_err(priv->ndev,
+			   "recv'd DLC is larger than PLSIZE of FIFO element.");
+
+	/* RX errors */
+	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DCRCERR |
+		      MCP25XXFD_CAN_BDIAG1_NCRCERR)) {
+		stats->rx_errors++;
+		if (cf)
+			cf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;
+	}
+	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DSTUFERR |
+		      MCP25XXFD_CAN_BDIAG1_NSTUFERR)) {
+		stats->rx_errors++;
+		if (cf)
+			cf->data[2] |= CAN_ERR_PROT_STUFF;
+	}
+	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DFORMERR |
+		      MCP25XXFD_CAN_BDIAG1_NFORMERR)) {
+		stats->rx_errors++;
+		if (cf)
+			cf->data[2] |= CAN_ERR_PROT_FORM;
+	}
+
+	/* TX errors */
+	if (bdiag1 & MCP25XXFD_CAN_BDIAG1_NACKERR) {
+		stats->tx_errors++;
+		if (cf) {
+			cf->can_id |= CAN_ERR_ACK;
+			cf->data[2] |= CAN_ERR_PROT_TX;
+		}
+	}
+	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DBIT1ERR |
+		      MCP25XXFD_CAN_BDIAG1_NBIT1ERR)) {
+		stats->tx_errors++;
+		if (cf)
+			cf->data[2] |= CAN_ERR_PROT_TX | CAN_ERR_PROT_BIT1;
+	}
+	if (bdiag1 & (MCP25XXFD_CAN_BDIAG1_DBIT0ERR |
+		      MCP25XXFD_CAN_BDIAG1_NBIT0ERR)) {
+		stats->tx_errors++;
+		if (cf)
+			cf->data[2] |= CAN_ERR_PROT_TX | CAN_ERR_PROT_BIT0;
+	}
+
+	if (!cf)
+		return 0;
+
+	err = can_rx_offload_queue_sorted(&priv->offload, skb, timestamp);
+	if (err)
+		stats->rx_fifo_errors++;
+
+	return 0;
+}
+
+static int mcp25xxfd_handle_cerrif(struct mcp25xxfd_priv *priv)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+	struct sk_buff *skb;
+	struct can_frame *cf = NULL;
+	enum can_state new_state, rx_state, tx_state;
+	u32 trec, timestamp;
+	int err;
+
+	/* The skb allocation might fail, but can_change_state()
+	 * handles cf == NULL.
+	 */
+	skb = mcp25xxfd_alloc_can_err_skb(priv, &cf, &timestamp);
+
+	err = regmap_read(priv->map, MCP25XXFD_CAN_TREC, &trec);
+	if (err)
+		return err;
+
+	if (trec & MCP25XXFD_CAN_TREC_TXBO)
+		tx_state = CAN_STATE_BUS_OFF;
+	else if (trec & MCP25XXFD_CAN_TREC_TXBP)
+		tx_state = CAN_STATE_ERROR_PASSIVE;
+	else if (trec & MCP25XXFD_CAN_TREC_TXWARN)
+		tx_state = CAN_STATE_ERROR_WARNING;
+	else
+		tx_state = CAN_STATE_ERROR_ACTIVE;
+
+	if (trec & MCP25XXFD_CAN_TREC_RXBP)
+		rx_state = CAN_STATE_ERROR_PASSIVE;
+	else if (trec & MCP25XXFD_CAN_TREC_RXWARN)
+		rx_state = CAN_STATE_ERROR_WARNING;
+	else
+		rx_state = CAN_STATE_ERROR_ACTIVE;
+
+	new_state = max(tx_state, rx_state);
+	if (new_state == priv->can.state)
+		return 0;
+
+	can_change_state(priv->ndev, cf, tx_state, rx_state);
+
+	if (new_state == CAN_STATE_BUS_OFF) {
+		mcp25xxfd_chip_stop(priv, CAN_STATE_BUS_OFF);
+		can_bus_off(priv->ndev);
+	}
+
+	if (!skb)
+		return 0;
+
+	if (new_state != CAN_STATE_BUS_OFF) {
+		struct can_berr_counter bec;
+
+		err = mcp25xxfd_get_berr_counter(priv->ndev, &bec);
+		cf->data[6] = bec.txerr;
+		cf->data[7] = bec.rxerr;
+	}
+
+	err = can_rx_offload_queue_sorted(&priv->offload, skb, timestamp);
+	if (err)
+		stats->rx_fifo_errors++;
+
+	return 0;
+}
+
+static int mcp25xxfd_handle_modif(const struct mcp25xxfd_priv *priv)
+{
+	const u8 mode_reference = mcp25xxfd_get_normal_mode(priv);
+	u8 mode;
+	int err;
+
+	err = mcp25xxfd_chip_get_mode(priv, &mode);
+	if (err)
+		return err;
+
+	if (mode == mode_reference)
+		return 0;
+
+	/* According to MCP2517FD errata DS80000792B, during a TX MAB
+	 * underflow, the controller will transition to Restricted
+	 * Operation Mode or Listen Only Mode (depending on SERR2LOM).
+	 *
+	 * However this is not always the case. When SERR2LOM is
+	 * configured for Restricted Operation Mode (SERR2LOM not set)
+	 * the MCP2517FD will sometimes transition to Listen Only Mode
+	 * first. When polling this bit we see that it will transition
+	 * to Restricted Operation Mode shortly after.
+	 */
+	if (mode == MCP25XXFD_CAN_CON_MODE_RESTRICTED ||
+	    mode == MCP25XXFD_CAN_CON_MODE_LISTENONLY)
+		netdev_dbg(priv->ndev,
+			    "Controller changed into %s Mode (%u).\n",
+			    mcp25xxfd_get_mode_str(mode), mode);
+	else
+		netdev_err(priv->ndev,
+			   "Controller changed into %s Mode (%u).\n",
+			   mcp25xxfd_get_mode_str(mode), mode);
+
+	/* After the application requests Normal mode, the CAN FD
+	 * Controller will automatically attempt to retransmit the
+	 * message that caused the TX MAB underflow.
+	 */
+	return mcp25xxfd_chip_set_normal_mode_nowait(priv);
+}
+
+static int mcp25xxfd_handle_serrif(struct mcp25xxfd_priv *priv)
+{
+	struct net_device_stats *stats = &priv->ndev->stats;
+
+	/* TX MAB underflow
+	 *
+	 * According to the MCP2517FD Errata DS80000792B a TX MAB
+	 * underflow is indicated by SERRIF and MODIF.
+	 *
+	 * Due to the corresponding Bus Errors, a IVMIF can be seen as
+	 * well.
+	 */
+	if ((priv->intf & MCP25XXFD_CAN_INT_MODIF) &&
+	    (priv->intf & MCP25XXFD_CAN_INT_IVMIF)) {
+		stats->tx_aborted_errors++;
+		stats->tx_errors++;
+
+		return 0;
+	}
+
+	/* RX MAB overflow
+	 *
+	 * According to the MCP2517FD Errata DS80000792B a RX MAB
+	 * overflow is indicated by SERRIF.
+	 */
+	if (priv->intf & MCP25XXFD_CAN_INT_RXIF) {
+		stats->rx_dropped++;
+		stats->rx_errors++;
+
+		return 0;
+	}
+
+	return 0;
+}
+
+static int mcp25xxfd_handle_eccif(struct mcp25xxfd_priv *priv)
+{
+	int err;
+	u32 ecc_stat;
+
+	err = regmap_read(priv->map, MCP25XXFD_ECCSTAT, &ecc_stat);
+	if (err)
+		return err;
+
+	err = regmap_update_bits(priv->map, MCP25XXFD_ECCSTAT,
+				 MCP25XXFD_ECCSTAT_IF_MASK,
+				 ~ecc_stat);
+	if (err)
+		return err;
+
+	if (ecc_stat & MCP25XXFD_ECCSTAT_SECIF)
+		netdev_info(priv->ndev,
+			    "Single ECC Error corrected at address 0x%04lx.\n",
+			    FIELD_GET(MCP25XXFD_ECCSTAT_ERRADDR_MASK,
+				      ecc_stat));
+	else if (ecc_stat & MCP25XXFD_ECCSTAT_DEDIF)
+		netdev_notice(priv->ndev,
+			      "Double ECC Error detected at address 0x%04lx.\n",
+			      FIELD_GET(MCP25XXFD_ECCSTAT_ERRADDR_MASK,
+					ecc_stat));
+
+	return 0;
+}
+
+static int mcp25xxfd_handle_spicrcif(struct mcp25xxfd_priv *priv)
+{
+	int err;
+	u32 crc;
+
+	err = regmap_read(priv->map, MCP25XXFD_CRC, &crc);
+	if (err)
+		return err;
+
+	err = regmap_update_bits(priv->map, MCP25XXFD_CRC,
+				 MCP25XXFD_CRC_IF_MASK,
+				 ~crc);
+	if (err)
+		return err;
+
+	if (crc & MCP25XXFD_CRC_FERRIF)
+		netdev_info(priv->ndev, "CRC Command Format Error.\n");
+	else if (crc & MCP25XXFD_CRC_CRCERRIF)
+		netdev_notice(priv->ndev, "CRC Error detected. CRC=0x%04lx.\n",
+			      FIELD_GET(MCP25XXFD_CRC_MASK, crc));
+
+	return 0;
+}
+
+#define mcp25xxfd_handle(priv, irq, ...) \
+({ \
+	int err; \
+\
+	err = mcp25xxfd_handle_##irq(priv, ## __VA_ARGS__); \
+	if (err) \
+		netdev_err(priv->ndev, \
+			"IRQ handler mcp25xxfd_handle_%s() returned %d.\n", \
+			__stringify(irq), err); \
+	err; \
+})
+
+static irqreturn_t mcp25xxfd_irq(int irq, void *dev_id)
+{
+	struct mcp25xxfd_priv *priv = dev_id;
+	irqreturn_t handled = IRQ_NONE;
+	int err;
+
+	if (priv->rx_int)
+		do {
+			int rx_pending;
+
+			rx_pending = gpiod_get_value_cansleep(priv->rx_int);
+			if (!rx_pending)
+				break;
+
+			err = mcp25xxfd_handle(priv, rxif);
+			if (err)
+				goto out_fail;
+
+			handled = IRQ_HANDLED;
+		} while (1);
+
+	do {
+		u32 intf_pending, intf_pending_clearable;
+
+		err = regmap_read(priv->map, MCP25XXFD_CAN_INT, &priv->intf);
+		if (err)
+			goto out_fail;
+
+		intf_pending = FIELD_GET(MCP25XXFD_CAN_INT_IF_MASK, priv->intf) &
+			FIELD_GET(MCP25XXFD_CAN_INT_IE_MASK, priv->intf);
+
+		if (!(intf_pending))
+			return handled;
+
+		/* Some interrupts must be ACKed in the
+		 * MCP25XXFD_CAN_INT register.
+		 * - First ACK then handle, to avoid lost-IRQ race
+		 *   condition on fast re-occuring interrupts.
+		 * - Write "0" to clear active IRQs, "1" to all other,
+		 *   to avoid r/m/w race condition on the
+		 *   MCP25XXFD_CAN_INT register.
+		 */
+		intf_pending_clearable = intf_pending &
+			MCP25XXFD_CAN_INT_IF_CLEARABLE_MASK;
+		if (intf_pending_clearable) {
+			err = regmap_update_bits(priv->map, MCP25XXFD_CAN_INT,
+						 MCP25XXFD_CAN_INT_IF_MASK,
+						 ~intf_pending_clearable);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_MODIF) {
+			err = mcp25xxfd_handle(priv, modif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_RXIF) {
+			err = mcp25xxfd_handle(priv, rxif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_TEFIF) {
+			err = mcp25xxfd_handle(priv, tefif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_RXOVIF) {
+			err = mcp25xxfd_handle(priv, rxovif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_TXATIF) {
+			err = mcp25xxfd_handle(priv, txatif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_IVMIF) {
+			err = mcp25xxfd_handle(priv, ivmif);
+			if (err)
+				goto out_fail;
+		}
+
+		/* On the MCP2527FD and MCP2518FD, we don't get a
+		 * CERRIF IRQ on the transition TX ERROR_WARNING -> TX
+		 * ERROR_ACTIVE.
+		 */
+		if (intf_pending & MCP25XXFD_CAN_INT_CERRIF ||
+		    priv->can.state > CAN_STATE_ERROR_ACTIVE) {
+			err = mcp25xxfd_handle(priv, cerrif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_SERRIF) {
+			err = mcp25xxfd_handle(priv, serrif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_ECCIF) {
+			err = mcp25xxfd_handle(priv, eccif);
+			if (err)
+				goto out_fail;
+		}
+
+		if (intf_pending & MCP25XXFD_CAN_INT_SPICRCIE) {
+			err = mcp25xxfd_handle(priv, spicrcif);
+			if (err)
+				goto out_fail;
+		}
+
+		handled = IRQ_HANDLED;
+	} while (1);
+
+ out_fail:
+	netdev_err(priv->ndev, "IRQ handler returned %d.\n", err);
+	mcp25xxfd_dump(priv);
+	mcp25xxfd_log_dump(priv);
+	mcp25xxfd_chip_interrupts_disable(priv);
+
+	return handled;
+}
+
+static inline struct
+mcp25xxfd_tx_obj *mcp25xxfd_get_tx_obj_next(struct mcp25xxfd_priv *priv)
+{
+	u8 tx_head;
+
+	tx_head = mcp25xxfd_get_tx_head(priv);
+
+	return &priv->tx.obj[tx_head];
+}
+
+static void
+mcp25xxfd_tx_obj_from_skb(const struct mcp25xxfd_priv *priv,
+			  struct mcp25xxfd_tx_obj *tx_obj,
+			  const struct sk_buff *skb)
+{
+	const struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
+	struct mcp25xxfd_hw_tx_obj_raw *hw_tx_obj = &tx_obj->load.buf.hw_tx_obj;
+	u32 id, flags, len;
+
+	if (cfd->can_id & CAN_EFF_FLAG) {
+		u32 sid, eid;
+
+		sid = FIELD_GET(MCP25XXFD_CAN_FRAME_EFF_SID_MASK, cfd->can_id);
+		eid = FIELD_GET(MCP25XXFD_CAN_FRAME_EFF_EID_MASK, cfd->can_id);
+
+		id = FIELD_PREP(MCP25XXFD_OBJ_ID_EID_MASK, eid) |
+			FIELD_PREP(MCP25XXFD_OBJ_ID_SID_MASK, sid);
+
+		flags = MCP25XXFD_OBJ_FLAGS_IDE;
+	} else {
+		id = FIELD_PREP(MCP25XXFD_OBJ_ID_SID_MASK, cfd->can_id);
+		flags = 0;
+	}
+
+	/* Use the MCP2518FD mask even on the MCP2517FD. It doesn't
+	 * harm, only the lower 7 bits will be transferred into the
+	 * TEF object.
+	 */
+	flags |= FIELD_PREP(MCP25XXFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK,
+			    priv->tx.head) |
+		FIELD_PREP(MCP25XXFD_OBJ_FLAGS_DLC, can_len2dlc(cfd->len));
+
+	if (cfd->can_id & CAN_RTR_FLAG)
+		flags |= MCP25XXFD_OBJ_FLAGS_RTR;
+
+	/* CANFD */
+	if (can_is_canfd_skb(skb)) {
+		if (cfd->flags & CANFD_ESI)
+			flags |= MCP25XXFD_OBJ_FLAGS_ESI;
+
+		flags |= MCP25XXFD_OBJ_FLAGS_FDF;
+
+		if (cfd->flags & CANFD_BRS)
+			flags |= MCP25XXFD_OBJ_FLAGS_BRS;
+	}
+
+	put_unaligned_le32(id, &hw_tx_obj->id);
+	put_unaligned_le32(flags, &hw_tx_obj->flags);
+
+	// FIXME: what does the controller send in CANFD if can_dlc2len(can_len2dlc(cfd->len)) > cfd->len?
+	memset(hw_tx_obj->data + round_down(cfd->len, sizeof(u32)),
+	       0x0, sizeof(u32));
+	memcpy(hw_tx_obj->data, cfd->data, cfd->len);
+
+	len = sizeof(tx_obj->load.buf.cmd);
+	len += sizeof(hw_tx_obj->id) + sizeof(hw_tx_obj->flags);
+	len += round_up(cfd->len, sizeof(u32));
+
+	tx_obj->load.xfer.len = len;
+}
+
+static int mcp25xxfd_tx_obj_write(const struct mcp25xxfd_priv *priv,
+				  struct mcp25xxfd_tx_obj *tx_obj)
+{
+	int err;
+
+	err = spi_async(priv->spi, &tx_obj->load.msg);
+	if (err)
+		return err;
+
+	return spi_async(priv->spi, &tx_obj->trigger.msg);
+}
+
+static netdev_tx_t mcp25xxfd_start_xmit(struct sk_buff *skb,
+					struct net_device *ndev)
+{
+	struct mcp25xxfd_priv *priv = netdev_priv(ndev);
+	struct mcp25xxfd_tx_obj *tx_obj;
+	const canid_t can_id = ((struct canfd_frame *)skb->data)->can_id;
+	u8 tx_head;
+	int err;
+
+	if (can_dropped_invalid_skb(ndev, skb))
+		return NETDEV_TX_OK;
+
+	mcp25xxfd_log(priv, can_id);
+
+	if (priv->tx.head - priv->tx.tail >= priv->tx.obj_num) {
+		netdev_info(priv->ndev,
+			   "Stopping tx-queue (tx_head=0x%08x, tx_tail=0x%08x, len=%d).\n",
+			   priv->tx.head, priv->tx.tail,
+			   priv->tx.head - priv->tx.tail);
+
+		mcp25xxfd_log_busy(priv, can_id);
+		netif_stop_queue(ndev);
+
+		return NETDEV_TX_BUSY;
+	}
+
+	tx_obj = mcp25xxfd_get_tx_obj_next(priv);
+	mcp25xxfd_tx_obj_from_skb(priv, tx_obj, skb);
+
+	// FIXME:
+	// if (!netdev_xmit_more() ||
+	//	netif_xmit_stopped(netdev_get_tx_queue(netdev, 0)))
+
+	/* Stop queue if we occupy the complete TX FIFO */
+	tx_head = mcp25xxfd_get_tx_head(priv);
+	priv->tx.head++;
+	if (priv->tx.head - priv->tx.tail >= priv->tx.obj_num) {
+		mcp25xxfd_log_stop(priv, can_id);
+		netif_stop_queue(ndev);
+	}
+
+	can_put_echo_skb(skb, ndev, tx_head);
+
+	err = mcp25xxfd_tx_obj_write(priv, tx_obj);
+	if (err)
+		goto out_err;
+
+	return NETDEV_TX_OK;
+
+ out_err:
+	netdev_err(priv->ndev, "ERROR in %s: %d\n", __func__, err);
+	mcp25xxfd_dump(priv);
+	mcp25xxfd_log_dump(priv);
+
+	return NETDEV_TX_OK;
+}
+
+static int mcp25xxfd_open(struct net_device *ndev)
+{
+	struct mcp25xxfd_priv *priv = netdev_priv(ndev);
+	const struct spi_device *spi = priv->spi;
+	int err;
+
+	err = pm_runtime_get_sync(ndev->dev.parent);
+	if (err < 0)
+		return err;
+
+	err = open_candev(ndev);
+	if (err)
+		goto out_pm_runtime_put;
+
+	err = request_threaded_irq(spi->irq, NULL, mcp25xxfd_irq,
+				   IRQF_ONESHOT, dev_name(&spi->dev),
+				   priv);
+	if (err)
+		goto out_close;
+
+	err = mcp25xxfd_transceiver_enable(priv);
+	if (err)
+		goto out_free_irq;
+
+	can_rx_offload_enable(&priv->offload);
+
+	err = mcp25xxfd_chip_start(priv);
+	if (err)
+		goto out_can_rx_offload_disable;
+
+	netif_start_queue(ndev);
+
+	return 0;
+
+ out_can_rx_offload_disable:
+	can_rx_offload_disable(&priv->offload);
+	mcp25xxfd_transceiver_disable(priv);
+ out_free_irq:
+	free_irq(spi->irq, priv);
+ out_close:
+	close_candev(ndev);
+ out_pm_runtime_put:
+	mcp25xxfd_chip_stop(priv, CAN_STATE_STOPPED);
+	pm_runtime_put(ndev->dev.parent);
+
+	return err;
+}
+
+static int mcp25xxfd_stop(struct net_device *ndev)
+{
+	struct mcp25xxfd_priv *priv = netdev_priv(ndev);
+
+	netif_stop_queue(ndev);
+	mcp25xxfd_chip_stop(priv, CAN_STATE_STOPPED);
+	can_rx_offload_disable(&priv->offload);
+	mcp25xxfd_transceiver_disable(priv);
+	free_irq(ndev->irq, priv);
+	close_candev(ndev);
+
+	pm_runtime_put(ndev->dev.parent);
+
+	return 0;
+}
+
+static const struct net_device_ops mcp25xxfd_netdev_ops = {
+	.ndo_open = mcp25xxfd_open,
+	.ndo_stop = mcp25xxfd_stop,
+	.ndo_start_xmit	= mcp25xxfd_start_xmit,
+	.ndo_change_mtu = can_change_mtu,
+};
+
+static int mcp25xxfd_register_chip_detect(struct mcp25xxfd_priv *priv)
+{
+	const struct net_device *ndev = priv->ndev;
+	u32 osc, osc_reference;
+	enum mcp25xxfd_model model;
+	int err;
+
+	osc_reference = MCP25XXFD_OSC_OSCRDY |
+		FIELD_PREP(MCP25XXFD_OSC_CLKODIV_MASK,
+			   MCP25XXFD_OSC_CLKODIV_10);
+
+	/* check reset defaults of OSC reg */
+	err = regmap_read(priv->map, MCP25XXFD_OSC, &osc);
+	if (err)
+		return err;
+
+	if (osc != osc_reference) {
+		netdev_err(ndev,
+			   "Chip failed to soft reset. osc=0x%08x, reference value=0x%08x\n",
+			   osc, osc_reference);
+		return -ENODEV;
+	}
+
+	/* The OSC_LPMEN is only supported on MCP2518FD, so use it to
+	 * autodetect the model.
+	 */
+	err = regmap_update_bits(priv->map, MCP25XXFD_OSC,
+				 MCP25XXFD_OSC_LPMEN, MCP25XXFD_OSC_LPMEN);
+	if (err)
+		return err;
+
+	err = regmap_read(priv->map, MCP25XXFD_OSC, &osc);
+	if (err)
+		return err;
+
+	if (osc & MCP25XXFD_OSC_LPMEN)
+		model = CAN_MCP2518FD;
+	else
+		model = CAN_MCP2517FD;
+
+	if (priv->model != CAN_MCP25XXFD &&
+	    priv->model != model) {
+		netdev_info(ndev,
+			    "Detected MCP%xFD, but firmware specifies a MCP%xFD. Fixing up.",
+			    model, priv->model);
+	}
+	priv->model = model;
+
+	return 0;
+}
+
+static int mcp25xxfd_register_check_rx_int(struct mcp25xxfd_priv *priv)
+{
+	int err, rx_pending;
+
+	if (!priv->rx_int)
+		return 0;
+
+	err = mcp25xxfd_chip_pinctrl_init(priv);
+	if (err)
+		return err;
+
+	/* Check if RX_INT is properly working. The RX-INT should not
+	 * be active after a softreset.
+	 */
+	rx_pending = gpiod_get_value_cansleep(priv->rx_int);
+	if (!rx_pending)
+		return 0;
+
+	netdev_info(priv->ndev,
+		   "RX-INT active after softreset, disabling RX-INT support.");
+	devm_gpiod_put(&priv->spi->dev, priv->rx_int);
+	priv->rx_int = NULL;
+
+	return 0;
+}
+
+static int mcp25xxfd_register(struct mcp25xxfd_priv *priv)
+{
+	struct net_device *ndev = priv->ndev;
+	int err;
+
+	err = mcp25xxfd_clks_and_vdd_enable(priv);
+	if (err)
+		return err;
+
+	pm_runtime_get_noresume(ndev->dev.parent);
+	err = pm_runtime_set_active(ndev->dev.parent);
+	if (err)
+		goto out_runtime_put_noidle;
+	pm_runtime_enable(ndev->dev.parent);
+
+	/* Wait for oscillator startup timer after power up */
+	mdelay(MCP25XXFD_OSC_DELAY_MS);
+
+	err = mcp25xxfd_chip_softreset(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_register_chip_detect(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = mcp25xxfd_register_check_rx_int(priv);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	err = register_candev(ndev);
+	if (err)
+		goto out_chip_set_mode_sleep;
+
+	if (priv->model == CAN_MCP2517FD) {
+		netdev_info(ndev, "MCP%xFD %ssuccessfully initialized.\n",
+			    priv->model, priv->rx_int ? "(+RX-INT) " : "");
+	} else {
+		u32 devid;
+
+		err = regmap_read(priv->map, MCP25XXFD_DEVID, &devid);
+		if (err)
+			goto out_unregister_candev;
+
+		netdev_info(ndev, "MCP%xFD rev%lu.%lu %ssuccessfully initialized.\n",
+			    priv->model,
+			    FIELD_GET(MCP25XXFD_DEVID_ID_MASK, devid),
+			    FIELD_GET(MCP25XXFD_DEVID_REV_MASK, devid),
+			    priv->rx_int ? "(+RX-INT) " : "");
+	}
+
+	/* Put core into sleep mode and let pm_runtime_put() disable
+	 * the clocks and vdd. If CONFIG_PM is not enabled, the clocks
+	 * and vdd will stay powered.
+	 */
+	err = mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_SLEEP);
+	if (err)
+		goto out_unregister_candev;
+
+	pm_runtime_put(ndev->dev.parent);
+
+	return 0;
+
+ out_unregister_candev:
+	unregister_candev(ndev);
+ out_chip_set_mode_sleep:
+	mcp25xxfd_chip_set_mode(priv, MCP25XXFD_CAN_CON_MODE_SLEEP);
+	pm_runtime_disable(ndev->dev.parent);
+ out_runtime_put_noidle:
+	pm_runtime_put_noidle(ndev->dev.parent);
+	mcp25xxfd_clks_and_vdd_disable(priv);
+
+	return err;
+}
+
+static inline void mcp25xxfd_unregister(struct mcp25xxfd_priv *priv)
+{
+	struct net_device *ndev	= priv->ndev;
+
+	unregister_candev(ndev);
+
+	pm_runtime_get_sync(ndev->dev.parent);
+	pm_runtime_put_noidle(ndev->dev.parent);
+	mcp25xxfd_clks_and_vdd_disable(priv);
+	pm_runtime_disable(ndev->dev.parent);
+}
+
+static const struct of_device_id mcp25xxfd_of_match[] = {
+	{
+		.compatible = "microchip,mcp2517fd",
+		.data = (void *)CAN_MCP2517FD,
+	}, {
+		.compatible = "microchip,mcp2518fd",
+		.data = (void *)CAN_MCP2518FD,
+	}, {
+		.compatible = "microchip,mcp25xxfd",
+		.data = (void *)CAN_MCP25XXFD,
+	}, {
+		/* sentinel */
+	},
+};
+MODULE_DEVICE_TABLE(of, mcp25xxfd_of_match);
+
+static const struct spi_device_id mcp25xxfd_id_table[] = {
+	{
+		.name = "mcp2517fd",
+		.driver_data = (kernel_ulong_t)CAN_MCP2517FD,
+	}, {
+		.name = "mcp2518fd",
+		.driver_data = (kernel_ulong_t)CAN_MCP2518FD,
+	}, {
+		.name = "mcp25xxfd",
+		.driver_data = (kernel_ulong_t)CAN_MCP25XXFD,
+	}, {
+		/* sentinel */
+	},
+};
+MODULE_DEVICE_TABLE(spi, mcp25xxfd_id_table);
+
+static int mcp25xxfd_probe(struct spi_device *spi)
+{
+	const void *match;
+	struct net_device *ndev;
+	struct mcp25xxfd_priv *priv;
+	struct gpio_desc *rx_int;
+	struct gpio_desc *gpiod_xceiver;
+	struct regulator *reg_vdd, *reg_xceiver;
+	struct clk *clk;
+	u32 freq;
+	int err;
+
+	rx_int = devm_gpiod_get_optional(&spi->dev, "rx-int", GPIOD_IN);
+	if (PTR_ERR(rx_int) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	else if (IS_ERR(rx_int))
+		return PTR_ERR(rx_int);
+
+	gpiod_xceiver = devm_gpiod_get_optional(&spi->dev, "xceiver", GPIOD_OUT_LOW);
+	if (IS_ERR(gpiod_xceiver))
+		return PTR_ERR(gpiod_xceiver);
+
+	reg_vdd = devm_regulator_get_optional(&spi->dev, "vdd");
+	if (PTR_ERR(reg_vdd) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	else if (PTR_ERR(reg_vdd) == -ENODEV)
+		reg_vdd = NULL;
+	else if (IS_ERR(reg_vdd))
+		return PTR_ERR(reg_vdd);
+
+	reg_xceiver = devm_regulator_get_optional(&spi->dev, "xceiver");
+	if (PTR_ERR(reg_xceiver) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	else if (PTR_ERR(reg_xceiver) == -ENODEV)
+		reg_xceiver = NULL;
+	else if (IS_ERR(reg_xceiver))
+		return PTR_ERR(reg_xceiver);
+
+	clk = devm_clk_get(&spi->dev, NULL);
+	if (IS_ERR(clk)) {
+		dev_err(&spi->dev, "No Oscillator (clock) defined.\n");
+		return PTR_ERR(clk);
+	}
+	freq = clk_get_rate(clk);
+
+	/* Sanity check */
+	if (freq < MCP25XXFD_SYSCLOCK_HZ_MIN ||
+	    freq > MCP25XXFD_SYSCLOCK_HZ_MAX) {
+		dev_err(&spi->dev, "Oscillator frequency is too low.\n");
+		return -ERANGE;
+	}
+
+	if (freq < MCP25XXFD_SYSCLOCK_HZ_MAX /
+	    MCP25XXFD_OSC_PLL_MULTIPLIER) {
+		dev_err(&spi->dev,
+			"Oscillator frequency is too low and PLL in not supported.\n");
+		return -ERANGE;
+	}
+
+	ndev = alloc_candev(sizeof(struct mcp25xxfd_priv),
+			    MCP25XXFD_TX_OBJ_NUM_MAX);
+	if (!ndev)
+		return -ENOMEM;
+
+	SET_NETDEV_DEV(ndev, &spi->dev);
+
+	ndev->netdev_ops = &mcp25xxfd_netdev_ops;
+	ndev->irq = spi->irq;
+	ndev->flags |= IFF_ECHO;
+
+	priv = netdev_priv(ndev);
+	spi_set_drvdata(spi, priv);
+	priv->can.clock.freq = freq;
+	priv->can.do_set_mode = mcp25xxfd_set_mode;
+	priv->can.do_get_berr_counter = mcp25xxfd_get_berr_counter;
+	priv->can.bittiming_const = &mcp25xxfd_bittiming_const;
+	priv->can.data_bittiming_const = &mcp25xxfd_data_bittiming_const;
+	priv->can.ctrlmode_supported = CAN_CTRLMODE_ONE_SHOT | CAN_CTRLMODE_FD |
+		CAN_CTRLMODE_BERR_REPORTING;
+	priv->ndev = ndev;
+	priv->spi = spi;
+	priv->rx_int = rx_int;
+	priv->clk = clk;
+	priv->reg_vdd = reg_vdd;
+	priv->reg_xceiver = reg_xceiver;
+	priv->gpiod_xceiver = gpiod_xceiver;
+	atomic_set(&priv->cnt, 0);
+
+	match = device_get_match_data(&spi->dev);
+	if (match)
+		priv->model = (enum mcp25xxfd_model)match;
+	else
+		priv->model = spi_get_device_id(spi)->driver_data;
+
+	spi->bits_per_word = 8;
+	/* SPI clock must be less or equal SYSCLOCK / 2 */
+	spi->max_speed_hz = min(spi->max_speed_hz, freq / 2);
+	err = spi_setup(spi);
+	if (err)
+		goto out_free_candev;
+
+	err = mcp25xxfd_regmap_init(priv);
+	if (err)
+		goto out_free_candev;
+
+	err = can_rx_offload_add_manual(ndev, &priv->offload,
+					MCP25XXFD_NAPI_WEIGHT);
+	if (err)
+		goto out_free_candev;
+
+	err = mcp25xxfd_register(priv);
+	if (err)
+		goto out_free_candev;
+
+	return 0;
+
+ out_free_candev:
+	free_candev(ndev);
+
+	return err;
+}
+
+static int mcp25xxfd_remove(struct spi_device *spi)
+{
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+	struct net_device *ndev = priv->ndev;
+
+	can_rx_offload_del(&priv->offload);
+	mcp25xxfd_unregister(priv);
+	free_candev(ndev);
+
+	return 0;
+}
+
+static int __maybe_unused mcp25xxfd_runtime_suspend(struct device *device)
+{
+	const struct mcp25xxfd_priv *priv = dev_get_drvdata(device);
+
+	return mcp25xxfd_clks_and_vdd_disable(priv);
+}
+
+static int __maybe_unused mcp25xxfd_runtime_resume(struct device *device)
+{
+	const struct mcp25xxfd_priv *priv = dev_get_drvdata(device);
+
+	return mcp25xxfd_clks_and_vdd_enable(priv);
+}
+
+static const struct dev_pm_ops mcp25xxfd_pm_ops = {
+	SET_RUNTIME_PM_OPS(mcp25xxfd_runtime_suspend,
+			   mcp25xxfd_runtime_resume, NULL)
+};
+
+static struct spi_driver mcp25xxfd_driver = {
+	.driver = {
+		.name = DEVICE_NAME,
+		.pm = &mcp25xxfd_pm_ops,
+		.of_match_table = mcp25xxfd_of_match,
+	},
+	.probe = mcp25xxfd_probe,
+	.remove = mcp25xxfd_remove,
+	.id_table = mcp25xxfd_id_table,
+};
+module_spi_driver(mcp25xxfd_driver);
+
+MODULE_AUTHOR("Marc Kleine-Budde <mkl@pengutornix.de>");
+MODULE_DESCRIPTION("Microchip MCP25xxFD Family CAN controller driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-crc16.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-crc16.c
new file mode 100644
index 000000000000..bd591bfb4ccc
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-crc16.c
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+//
+// Copyright (c) 2020 Pengutronix,
+//                    Marc Kleine-Budde <kernel@pengutronix.de>
+//
+// Based on:
+//
+// CAN bus driver for Microchip 25XXFD CAN Controller with SPI Interface
+//
+// Copyright (c) 2019 Martin Sperl <kernel@martin.sperl.org>
+//
+
+#include "mcp25xxfd.h"
+
+/* The standard crc16 in linux/crc16.h is unfortunately not computing
+ * the correct results (left shift vs. right shift). So here an
+ * implementation with a table generated with the help of:
+ *
+ * http://lkml.iu.edu/hypermail/linux/kernel/0508.1/1085.html
+ */
+static const u16 mcp25xxfd_crc16_table[] = {
+	0x0000, 0x8005, 0x800f, 0x000a, 0x801b, 0x001e, 0x0014, 0x8011,
+	0x8033, 0x0036, 0x003c, 0x8039, 0x0028, 0x802d, 0x8027, 0x0022,
+	0x8063, 0x0066, 0x006c, 0x8069, 0x0078, 0x807d, 0x8077, 0x0072,
+	0x0050, 0x8055, 0x805f, 0x005a, 0x804b, 0x004e, 0x0044, 0x8041,
+	0x80c3, 0x00c6, 0x00cc, 0x80c9, 0x00d8, 0x80dd, 0x80d7, 0x00d2,
+	0x00f0, 0x80f5, 0x80ff, 0x00fa, 0x80eb, 0x00ee, 0x00e4, 0x80e1,
+	0x00a0, 0x80a5, 0x80af, 0x00aa, 0x80bb, 0x00be, 0x00b4, 0x80b1,
+	0x8093, 0x0096, 0x009c, 0x8099, 0x0088, 0x808d, 0x8087, 0x0082,
+	0x8183, 0x0186, 0x018c, 0x8189, 0x0198, 0x819d, 0x8197, 0x0192,
+	0x01b0, 0x81b5, 0x81bf, 0x01ba, 0x81ab, 0x01ae, 0x01a4, 0x81a1,
+	0x01e0, 0x81e5, 0x81ef, 0x01ea, 0x81fb, 0x01fe, 0x01f4, 0x81f1,
+	0x81d3, 0x01d6, 0x01dc, 0x81d9, 0x01c8, 0x81cd, 0x81c7, 0x01c2,
+	0x0140, 0x8145, 0x814f, 0x014a, 0x815b, 0x015e, 0x0154, 0x8151,
+	0x8173, 0x0176, 0x017c, 0x8179, 0x0168, 0x816d, 0x8167, 0x0162,
+	0x8123, 0x0126, 0x012c, 0x8129, 0x0138, 0x813d, 0x8137, 0x0132,
+	0x0110, 0x8115, 0x811f, 0x011a, 0x810b, 0x010e, 0x0104, 0x8101,
+	0x8303, 0x0306, 0x030c, 0x8309, 0x0318, 0x831d, 0x8317, 0x0312,
+	0x0330, 0x8335, 0x833f, 0x033a, 0x832b, 0x032e, 0x0324, 0x8321,
+	0x0360, 0x8365, 0x836f, 0x036a, 0x837b, 0x037e, 0x0374, 0x8371,
+	0x8353, 0x0356, 0x035c, 0x8359, 0x0348, 0x834d, 0x8347, 0x0342,
+	0x03c0, 0x83c5, 0x83cf, 0x03ca, 0x83db, 0x03de, 0x03d4, 0x83d1,
+	0x83f3, 0x03f6, 0x03fc, 0x83f9, 0x03e8, 0x83ed, 0x83e7, 0x03e2,
+	0x83a3, 0x03a6, 0x03ac, 0x83a9, 0x03b8, 0x83bd, 0x83b7, 0x03b2,
+	0x0390, 0x8395, 0x839f, 0x039a, 0x838b, 0x038e, 0x0384, 0x8381,
+	0x0280, 0x8285, 0x828f, 0x028a, 0x829b, 0x029e, 0x0294, 0x8291,
+	0x82b3, 0x02b6, 0x02bc, 0x82b9, 0x02a8, 0x82ad, 0x82a7, 0x02a2,
+	0x82e3, 0x02e6, 0x02ec, 0x82e9, 0x02f8, 0x82fd, 0x82f7, 0x02f2,
+	0x02d0, 0x82d5, 0x82df, 0x02da, 0x82cb, 0x02ce, 0x02c4, 0x82c1,
+	0x8243, 0x0246, 0x024c, 0x8249, 0x0258, 0x825d, 0x8257, 0x0252,
+	0x0270, 0x8275, 0x827f, 0x027a, 0x826b, 0x026e, 0x0264, 0x8261,
+	0x0220, 0x8225, 0x822f, 0x022a, 0x823b, 0x023e, 0x0234, 0x8231,
+	0x8213, 0x0216, 0x021c, 0x8219, 0x0208, 0x820d, 0x8207, 0x0202
+};
+
+static inline u16 mcp25xxfd_crc16_byte(u16 crc, const u8 data)
+{
+	u8 index = (crc >> 8) ^ data;
+
+	return (crc << 8) ^ mcp25xxfd_crc16_table[index];
+}
+
+static u16 mcp25xxfd_crc16(u16 crc, u8 const *buffer, size_t len)
+{
+	while (len--)
+		crc = mcp25xxfd_crc16_byte(crc, *buffer++);
+
+	return crc;
+}
+
+u16 mcp25xxfd_crc16_compute(const void *cmd, size_t cmd_size,
+			    const void *data, size_t data_size)
+{
+	u16 crc = 0xffff;
+
+	crc = mcp25xxfd_crc16(crc, cmd, cmd_size);
+	crc = mcp25xxfd_crc16(crc, data, data_size);
+
+	return crc;
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c
new file mode 100644
index 000000000000..b04ec5000968
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-dump.c
@@ -0,0 +1,685 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+//
+// Copyright (c) 2019, 2020 Pengutronix,
+//                          Marc Kleine-Budde <kernel@pengutronix.de>
+//
+
+#include <linux/bitfield.h>
+#include <linux/kernel.h>
+
+#include "mcp25xxfd.h"
+
+#define __dump_bit(val, prefix, bit, desc) \
+	pr_info("%16s   %s\t\t%s\n", __stringify(bit), \
+		(val) & prefix##_##bit ? "x" : " ", desc)
+
+#define __dump_mask(val, prefix, mask, fmt, desc) \
+	pr_info("%16s = " fmt "\t\t%s\n", \
+		__stringify(mask), \
+		FIELD_GET(prefix##_##mask##_MASK, (val)), \
+		desc)
+
+static void mcp25xxfd_dump_reg_con(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("CON: con(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP25XXFD_CAN_CON, TXBWS, "0x%02lx", "Transmit Bandwidth Sharing");
+	__dump_bit(val, MCP25XXFD_CAN_CON, ABAT, "Abort All Pending Transmissions");
+	__dump_mask(val, MCP25XXFD_CAN_CON, REQOP, "0x%02lx", "Request Operation Mode");
+	__dump_mask(val, MCP25XXFD_CAN_CON, OPMOD, "0x%02lx", "Operation Mode Status");
+	__dump_bit(val, MCP25XXFD_CAN_CON, TXQEN, "Enable Transmit Queue");
+	__dump_bit(val, MCP25XXFD_CAN_CON, STEF, "Store in Transmit Event FIFO");
+	__dump_bit(val, MCP25XXFD_CAN_CON, SERR2LOM, "Transition to Listen Only Mode on System Error");
+	__dump_bit(val, MCP25XXFD_CAN_CON, ESIGM, "Transmit ESI in Gateway Mode");
+	__dump_bit(val, MCP25XXFD_CAN_CON, RTXAT, "Restrict Retransmission Attempts");
+	__dump_bit(val, MCP25XXFD_CAN_CON, BRSDIS, "Bit Rate Switching Disable");
+	__dump_bit(val, MCP25XXFD_CAN_CON, BUSY, "CAN Module is Busy");
+	__dump_mask(val, MCP25XXFD_CAN_CON, WFT, "0x%02lx", "Selectable Wake-up Filter Time");
+	__dump_bit(val, MCP25XXFD_CAN_CON, WAKFIL, "Enable CAN Bus Line Wake-up Filter");
+	__dump_bit(val, MCP25XXFD_CAN_CON, PXEDIS, "Protocol Exception Event Detection Disabled");
+	__dump_bit(val, MCP25XXFD_CAN_CON, ISOCRCEN, "Enable ISO CRC in CAN FD Frames");
+	__dump_mask(val, MCP25XXFD_CAN_CON, DNCNT, "0x%02lx", "Device Net Filter Bit Number");
+}
+
+static void mcp25xxfd_dump_reg_tbc(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TBC: tbc(0x%03x)=0x%08x\n", addr, val);
+}
+
+static void mcp25xxfd_dump_reg_vec(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	u8 rx_code, tx_code, i_code;
+
+	pr_info("VEC: vec(0x%03x)=0x%08x\n", addr, val);
+
+	rx_code = FIELD_GET(MCP25XXFD_CAN_VEC_RXCODE_MASK, val);
+	tx_code = FIELD_GET(MCP25XXFD_CAN_VEC_TXCODE_MASK, val);
+	i_code = FIELD_GET(MCP25XXFD_CAN_VEC_ICODE_MASK, val);
+
+	pr_info("\trxcode: ");
+	if (rx_code == 0x40)
+		pr_cont("No Interrupt");
+	else if (rx_code < 0x20)
+		pr_cont("FIFO %u", rx_code);
+	else
+		pr_cont("Reserved");
+	pr_cont(" (0x%02x)\n", rx_code);
+
+	pr_info("\ttxcode: ");
+	if (tx_code == 0x40)
+		pr_cont("No Interrupt");
+	else if (tx_code < 0x20)
+		pr_cont("FIFO %u", tx_code);
+	else
+		pr_cont("Reserved");
+	pr_cont(" (0x%02x)\n", tx_code);
+
+	pr_info("\ticode: ");
+	if (i_code == 0x4a)
+		pr_cont("Transmit Attempt Interrupt");
+	else if (i_code == 0x49)
+		pr_cont("Transmit Event FIFO Interrupt");
+	else if (i_code == 0x48)
+		pr_cont("Invalid Message Occurred");
+	else if (i_code == 0x47)
+		pr_cont("Operation Mode Changed");
+	else if (i_code == 0x46)
+		pr_cont("TBC Overflow");
+	else if (i_code == 0x45)
+		pr_cont("RX/TX MAB Overflow/Underflow");
+	else if (i_code == 0x44)
+		pr_cont("Address Error Interrupt");
+	else if (i_code == 0x43)
+		pr_cont("Receive FIFO Overflow Interrupt");
+	else if (i_code == 0x42)
+		pr_cont("Wake-up Interrupt");
+	else if (i_code == 0x41)
+		pr_cont("Error Interrupt");
+	else if (i_code == 0x40)
+		pr_cont("No Interrupt");
+	else if (i_code < 0x20)
+		pr_cont("FIFO %u", i_code);
+	else
+		pr_cont("Reserved");
+	pr_cont(" (0x%02x)\n", i_code);
+}
+
+#define __dump_int(val, bit, desc) \
+	pr_info("\t" __stringify(bit) "\t%s\t%s\t%s\t%s\n", \
+		 (val) & MCP25XXFD_CAN_INT_##bit##E ? "x" : "", \
+		 (val) & MCP25XXFD_CAN_INT_##bit##F ? "x" : "", \
+		 FIELD_GET(MCP25XXFD_CAN_INT_IF_MASK, val) & \
+		 FIELD_GET(MCP25XXFD_CAN_INT_IE_MASK, val) & \
+		 MCP25XXFD_CAN_INT_##bit##F ? "x" : "", \
+		 desc)
+
+static void mcp25xxfd_dump_reg_intf(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("INT: intf(0x%03x)=0x%08x\n", addr, val);
+
+	pr_info("\t\tIE\tIF\tIE & IF\n");
+	__dump_int(val, IVMI, "Invalid Message Interrupt");
+	__dump_int(val, WAKI, "Bus Wake Up Interrupt");
+	__dump_int(val, CERRI, "CAN Bus Error Interrupt");
+	__dump_int(val, SERRI, "System Error Interrupt");
+	__dump_int(val, RXOVI, "Receive FIFO Overflow Interrupt");
+	__dump_int(val, TXATI, "Transmit Attempt Interrupt");
+	__dump_int(val, SPICRCI, "SPI CRC Error Interrupt");
+	__dump_int(val, ECCI, "ECC Error Interrupt");
+	__dump_int(val, TEFI, "Transmit Event FIFO Interrupt");
+	__dump_int(val, MODI, "Mode Change Interrupt");
+	__dump_int(val, TBCI, "Time Base Counter Interrupt");
+	__dump_int(val, RXI, "Receive FIFO Interrupt");
+	__dump_int(val, TXI, "Transmit FIFO Interrupt");
+}
+
+#undef __dump_int
+
+#define __create_dump_fifo_bitmask(fifo, name, description) \
+static void mcp25xxfd_dump_reg_##fifo(const struct mcp25xxfd_priv *priv, u32 val, u16 addr) \
+{ \
+	int i; \
+\
+	pr_info(__stringify(name) ": " __stringify(fifo) "(0x%03x)=0x%08x\n", addr, val); \
+	pr_info(description ":\n"); \
+	if (!val) { \
+		pr_info("\t\t-none-\n"); \
+		return; \
+	} \
+\
+	pr_info("\t\t"); \
+	for (i = 0; i < sizeof(val); i++) { \
+		if (val & BIT(i)) \
+			pr_cont("%d ", i); \
+	} \
+\
+	pr_cont("\n"); \
+}
+
+__create_dump_fifo_bitmask(rxif, RXIF, "Receive FIFO Interrupt Pending bits");
+__create_dump_fifo_bitmask(rxovif, RXOVIF, "Receive FIFO Overflow Interrupt Pending bits");
+__create_dump_fifo_bitmask(txif, TXIF, "Transmit FIFO Interrupt Pending bits");
+__create_dump_fifo_bitmask(txatif, TXATIF, "Transmit FIFO Attempt Interrupt Pending bits");
+__create_dump_fifo_bitmask(txreq, TXREQ, "Message Send Request bits");
+
+#undef __create_dump_fifo_bitmask
+
+static void mcp25xxfd_dump_reg_trec(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TREC: trec(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP25XXFD_CAN_TREC, TXBO, "Transmitter in Bus Off State");
+	__dump_bit(val, MCP25XXFD_CAN_TREC, TXBP, "Transmitter in Error Passive State");
+	__dump_bit(val, MCP25XXFD_CAN_TREC, RXBP, "Receiver in Error Passive State");
+	__dump_bit(val, MCP25XXFD_CAN_TREC, TXWARN, "Transmitter in Error Warning State");
+	__dump_bit(val, MCP25XXFD_CAN_TREC, RXWARN, "Receiver in Error Warning State");
+	__dump_bit(val, MCP25XXFD_CAN_TREC, EWARN, "Transmitter or Receiver is in Error Warning State");
+
+	__dump_mask(val, MCP25XXFD_CAN_TREC, TEC, "%3lu", "Transmit Error Counter");
+	__dump_mask(val, MCP25XXFD_CAN_TREC, REC, "%3lu", "Receive Error Counter");
+}
+
+static void mcp25xxfd_dump_reg_bdiag0(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("BDIAG0: bdiag0(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP25XXFD_CAN_BDIAG0, DTERRCNT, "%3lu", "Data Bit Rate Transmit Error Counter");
+	__dump_mask(val, MCP25XXFD_CAN_BDIAG0, DRERRCNT, "%3lu", "Data Bit Rate Receive Error Counter");
+	__dump_mask(val, MCP25XXFD_CAN_BDIAG0, NTERRCNT, "%3lu", "Nominal Bit Rate Transmit Error Counter");
+	__dump_mask(val, MCP25XXFD_CAN_BDIAG0, NRERRCNT, "%3lu", "Nominal Bit Rate Receive Error Counter");
+}
+
+static void mcp25xxfd_dump_reg_bdiag1(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("BDIAG1: bdiag1(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DLCMM, "DLC Mismatch");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, ESI, "ESI flag of a received CAN FD message was set");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DCRCERR, "Data CRC Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DSTUFERR, "Data Bit Stuffing Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DFORMERR, "Data Format Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DBIT1ERR, "Data BIT1 Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, DBIT0ERR, "Data BIT0 Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, TXBOERR, "Device went to bus-off (and auto-recovered)");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NCRCERR, "CRC Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NSTUFERR, "Bit Stuffing Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NFORMERR, "Format Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NACKERR, "Transmitted message was not acknowledged");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NBIT1ERR, "Bit1 Error");
+	__dump_bit(val, MCP25XXFD_CAN_BDIAG1, NBIT0ERR, "Bit0 Error");
+	__dump_mask(val, MCP25XXFD_CAN_BDIAG1, EFMSGCNT, "%3lu", "Error Free Message Counter bits");
+}
+
+static void mcp25xxfd_dump_reg_osc(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("OSC: osc(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP25XXFD_OSC, SCLKRDY, "Synchronized SCLKDIV");
+	__dump_bit(val, MCP25XXFD_OSC, OSCRDY, "Clock Ready");
+	__dump_bit(val, MCP25XXFD_OSC, PLLRDY, "PLL Ready");
+	__dump_mask(val, MCP25XXFD_OSC, CLKODIV, "%2lu", "Clock Output Divisor");
+	__dump_bit(val, MCP25XXFD_OSC, SCLKDIV, "System Clock Divisor");
+	__dump_bit(val, MCP25XXFD_OSC, LPMEN, "Low Power Mode (LPM) Enable (MCP2518FD only)");
+	__dump_bit(val, MCP25XXFD_OSC, OSCDIS, "Clock (Oscillator) Disable");
+	__dump_bit(val, MCP25XXFD_OSC, PLLEN, "PLL Enable");
+}
+
+static void mcp25xxfd_dump_reg_tefcon(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TEFCON: tefcon(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP25XXFD_CAN_TEFCON, FSIZE, "%3lu", "FIFO Size");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, FRESET, "FIFO Reset");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, UINC, "Increment Tail");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFTSEN, "Transmit Event FIFO Time Stamp Enable");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFOVIE, "Transmit Event FIFO Overflow Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFFIE, "Transmit Event FIFO Full Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFHIE, "Transmit Event FIFO Half Full Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_TEFCON, TEFNEIE, "Transmit Event FIFO Not Empty Interrupt Enable");
+}
+
+static void mcp25xxfd_dump_reg_tefsta(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TEFSTA: tefsta(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_bit(val, MCP25XXFD_CAN_TEFSTA, TEFOVIF, "Transmit Event FIFO Overflow Interrupt Flag");
+	__dump_bit(val, MCP25XXFD_CAN_TEFSTA, TEFFIF, "Transmit Event FIFO Full Interrupt Flag (0 = not full)");
+	__dump_bit(val, MCP25XXFD_CAN_TEFSTA, TEFHIF, "Transmit Event FIFO Half Full Interrupt Flag (0= < half full)");
+	__dump_bit(val, MCP25XXFD_CAN_TEFSTA, TEFNEIF, "Transmit Event FIFO Not Empty Interrupt Flag (0=empty)");
+}
+
+static void mcp25xxfd_dump_reg_tefua(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("TEFUA: tefua(0x%03x)=0x%08x\n", addr, val);
+}
+
+static void mcp25xxfd_dump_reg_fifocon(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("FIFOCON: fifocon(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP25XXFD_CAN_FIFOCON, PLSIZE, "%3lu", "Payload Size");
+	__dump_mask(val, MCP25XXFD_CAN_FIFOCON, FSIZE, "%3lu", "FIFO Size");
+	__dump_mask(val, MCP25XXFD_CAN_FIFOCON, TXAT, "%3lu", "Retransmission Attempts");
+	__dump_mask(val, MCP25XXFD_CAN_FIFOCON, TXPRI, "%3lu", "Message Transmit Priority");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, FRESET, "FIFO Reset");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TXREQ, "Message Send Request");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, UINC, "Increment Head/Tail");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TXEN, "TX/RX FIFO Selection (0=RX, 1=TX)");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, RTREN, "Auto RTR Enable");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, RXTSEN, "Received Message Time Stamp Enable");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TXATIE, "Transmit Attempts Exhausted Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, RXOVIE, "Overflow Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TFERFFIE, "Transmit/Receive FIFO Empty/Full Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TFHRFHIE, "Transmit/Receive FIFO Half Empty/Half Full Interrupt Enable");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOCON, TFNRFNIE, "Transmit/Receive FIFO Not Full/Not Empty Interrupt Enable");
+}
+
+static void mcp25xxfd_dump_reg_fifosta(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("FIFOSTA: fifosta(0x%03x)=0x%08x\n", addr, val);
+
+	__dump_mask(val, MCP25XXFD_CAN_FIFOSTA, FIFOCI, "%3lu", "FIFO Message Index");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TXABT, "Message Aborted Status (1=aborted, 0=completed successfully)");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TXLARB, "Message Lost Arbitration Status");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TXERR, "Error Detected During Transmission");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TXATIF, "Transmit Attempts Exhausted Interrupt Pending");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, RXOVIF, "Receive FIFO Overflow Interrupt Flag");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TFERFFIF, "Transmit/Receive FIFO Empty/Full Interrupt Flag");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TFHRFHIF, "Transmit/Receive FIFO Half Empty/Half Full Interrupt Flag");
+	__dump_bit(val, MCP25XXFD_CAN_FIFOSTA, TFNRFNIF, "Transmit/Receive FIFO Not Full/Not Empty Interrupt Flag");
+}
+
+static void mcp25xxfd_dump_reg_fifoua(const struct mcp25xxfd_priv *priv, u32 val, u16 addr)
+{
+	pr_info("FIFOUA: fifoua(0x%03x)=0x%08x\n", addr, val);
+}
+
+#define __dump_call(regs, val) \
+do { \
+	mcp25xxfd_dump_reg_##val(priv, (regs)->val, (u16)offsetof(typeof(*(regs)), val)); \
+	pr_info("\n"); \
+} while (0)
+
+#define __dump_call_fifo(reg, val) \
+do { \
+	mcp25xxfd_dump_reg_##reg(priv, regs->val, (u16)offsetof(typeof(*regs), val)); \
+	pr_info("\n"); \
+} while (0)
+
+static void
+mcp25xxfd_dump_regs(const struct mcp25xxfd_priv *priv,
+		    const struct mcp25xxfd_dump_regs *regs,
+		    const struct mcp25xxfd_dump_regs_mcp25xxfd *regs_mcp25xxfd)
+{
+	netdev_info(priv->ndev, "-------------------- register dump --------------------\n");
+	__dump_call(regs_mcp25xxfd, osc);
+	__dump_call(regs, con);
+	__dump_call(regs, tbc);
+	__dump_call(regs, vec);
+	__dump_call(regs, intf);
+	__dump_call(regs, rxif);
+	__dump_call(regs, rxovif);
+	__dump_call(regs, txif);
+	__dump_call(regs, txatif);
+	__dump_call(regs, txreq);
+	__dump_call(regs, trec);
+	__dump_call(regs, bdiag0);
+	__dump_call(regs, bdiag1);
+	pr_info("-------------------- TEF --------------------\n");
+	__dump_call(regs, tefcon);
+	__dump_call(regs, tefsta);
+	__dump_call(regs, tefua);
+	pr_info("-------------------- TX_FIFO --------------------\n");
+	__dump_call_fifo(fifocon, fifo[MCP25XXFD_TX_FIFO].con);
+	__dump_call_fifo(fifosta, fifo[MCP25XXFD_TX_FIFO].sta);
+	__dump_call_fifo(fifoua, fifo[MCP25XXFD_TX_FIFO].ua);
+	pr_info(" -------------------- RX_FIFO --------------------\n");
+	__dump_call_fifo(fifocon, fifo[MCP25XXFD_RX_FIFO(0)].con);
+	__dump_call_fifo(fifosta, fifo[MCP25XXFD_RX_FIFO(0)].sta);
+	__dump_call_fifo(fifoua, fifo[MCP25XXFD_RX_FIFO(0)].ua);
+	netdev_info(priv->ndev, "------------------------- end -------------------------\n");
+}
+
+#undef __dump_call
+#undef __dump_call_fifo
+
+static u8 mcp25xxfd_dump_get_fifo_size(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u32 fifo_con)
+{
+	u8 obj_size;
+
+	obj_size = FIELD_GET(MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK, fifo_con);
+	switch (obj_size) {
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_8:
+		return 8;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_12:
+		return 12;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_16:
+		return 16;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_20:
+		return 20;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_24:
+		return 24;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_32:
+		return 32;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_48:
+		return 48;
+	case MCP25XXFD_CAN_FIFOCON_PLSIZE_64:
+		return 64;
+	}
+
+	return 0;
+}
+
+static u8 mcp25xxfd_dump_get_fifo_obj_num(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u32 fifo_con)
+{
+	u8 obj_num;
+
+	obj_num = FIELD_GET(MCP25XXFD_CAN_FIFOCON_FSIZE_MASK, fifo_con);
+
+	return obj_num + 1;
+}
+
+static void mcp25xxfd_dump_ram_fifo_obj_data(const struct mcp25xxfd_priv *priv, const u8 *data, u8 dlc)
+{
+	int i;
+	u8 len;
+
+	len = can_dlc2len(get_canfd_dlc(dlc));
+
+	if (!len) {
+		pr_info("%16s = -none-\n", "data");
+		return;
+	}
+
+	for (i = 0; i < len; i++) {
+		if ((i % 8) == 0) {
+			if (i == 0)
+				pr_info("%16s = %02x", "data", data[i]);
+			else
+				pr_info("                   %02x", data[i]);
+		} else if ((i % 4) == 0) {
+			pr_cont("  %02x", data[i]);
+		} else if ((i % 8) == 7) {
+			pr_cont(" %02x\n", data[i]);
+		} else {
+			pr_cont(" %02x", data[i]);
+		}
+	}
+
+	if (i % 8)
+		pr_cont("\n");
+}
+
+/* TEF */
+
+static u8 mcp25xxfd_dump_get_tef_obj_num(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return mcp25xxfd_dump_get_fifo_obj_num(priv, regs, regs->tef.con);
+}
+
+static u8 mcp25xxfd_dump_get_tef_tail(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return regs->tefua / sizeof(struct mcp25xxfd_hw_tef_obj);
+}
+
+static u16 mcp25xxfd_dump_get_tef_obj_rel_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return sizeof(struct mcp25xxfd_hw_tef_obj) * n;
+}
+
+static u16 mcp25xxfd_dump_get_tef_obj_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return mcp25xxfd_dump_get_tef_obj_rel_addr(priv, n) + MCP25XXFD_RAM_START;
+}
+
+/* TX */
+
+static u8 mcp25xxfd_dump_get_tx_obj_size(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return sizeof(struct mcp25xxfd_hw_tx_obj_can) -
+		FIELD_SIZEOF(struct mcp25xxfd_hw_tx_obj_can, data) +
+		mcp25xxfd_dump_get_fifo_size(priv, regs, regs->tx_fifo.con);
+}
+
+static u8 mcp25xxfd_dump_get_tx_obj_num(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return mcp25xxfd_dump_get_fifo_obj_num(priv, regs, regs->tx_fifo.con);
+}
+
+static u16 mcp25xxfd_dump_get_tx_obj_rel_addr(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u8 n)
+{
+	return mcp25xxfd_dump_get_tef_obj_rel_addr(priv, mcp25xxfd_dump_get_tef_obj_num(priv, regs)) +
+		mcp25xxfd_dump_get_tx_obj_size(priv, regs) * n;
+}
+
+static u16 mcp25xxfd_dump_get_tx_obj_addr(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u8 n)
+{
+	return mcp25xxfd_dump_get_tx_obj_rel_addr(priv, regs, n) + MCP25XXFD_RAM_START;
+}
+
+static u8 mcp25xxfd_dump_get_tx_tail(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return (regs->fifo[MCP25XXFD_TX_FIFO].ua -
+		mcp25xxfd_dump_get_tx_obj_rel_addr(priv, regs, 0)) /
+		mcp25xxfd_dump_get_tx_obj_size(priv, regs);
+}
+
+static u8 mcp25xxfd_dump_get_tx_head(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return FIELD_GET(MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK, regs->fifo[MCP25XXFD_TX_FIFO].sta);
+}
+
+/* RX */
+
+static u8 mcp25xxfd_dump_get_rx_obj_size(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return sizeof(struct mcp25xxfd_hw_rx_obj_can) -
+		FIELD_SIZEOF(struct mcp25xxfd_hw_rx_obj_can, data) +
+		mcp25xxfd_dump_get_fifo_size(priv, regs, regs->rx_fifo.con);
+}
+
+static u8 mcp25xxfd_dump_get_rx_obj_num(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return mcp25xxfd_dump_get_fifo_obj_num(priv, regs, regs->rx_fifo.con);
+}
+
+static u16 mcp25xxfd_dump_get_rx_obj_rel_addr(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u8 n)
+{
+	return mcp25xxfd_dump_get_tx_obj_rel_addr(priv, regs, mcp25xxfd_dump_get_tx_obj_num(priv, regs)) +
+		mcp25xxfd_dump_get_rx_obj_size(priv, regs) * n;
+}
+
+static u16 mcp25xxfd_dump_get_rx_obj_addr(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, u8 n)
+{
+	return mcp25xxfd_dump_get_rx_obj_rel_addr(priv, regs, n) + MCP25XXFD_RAM_START;
+}
+
+static u8 mcp25xxfd_dump_get_rx_tail(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return (regs->fifo[MCP25XXFD_RX_FIFO(0)].ua -
+		mcp25xxfd_dump_get_rx_obj_rel_addr(priv, regs, 0)) /
+		mcp25xxfd_dump_get_rx_obj_size(priv, regs);
+}
+
+static u8 mcp25xxfd_dump_get_rx_head(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs)
+{
+	return FIELD_GET(MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK, regs->fifo[MCP25XXFD_RX_FIFO(0)].sta);
+}
+
+/* dump TEF */
+
+static void mcp25xxfd_dump_ram_tef_obj_one(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_hw_tef_obj *hw_tef_obj, u8 n)
+{
+	pr_info("TEF Object: 0x%02x (0x%03x)%s%s%s%s%s\n",
+		n, mcp25xxfd_dump_get_tef_obj_addr(priv, n),
+		mcp25xxfd_get_tef_head(priv) == n ? "  priv-HEAD" : "",
+		mcp25xxfd_dump_get_tef_tail(priv, regs) == n ? "  chip-TAIL" : "",
+		mcp25xxfd_get_tef_tail(priv) == n ? "  priv-TAIL" : "",
+		(mcp25xxfd_dump_get_tef_tail(priv, regs) == n ?
+		 ((regs->tef.sta & MCP25XXFD_CAN_TEFSTA_TEFFIF) ? "  chip-FIFO-full" :
+		  !(regs->tef.sta & MCP25XXFD_CAN_TEFSTA_TEFNEIF) ? "  chip-FIFO-empty" : "") :
+		 ("")),
+		(mcp25xxfd_get_tef_head(priv) == mcp25xxfd_get_tef_tail(priv) &&
+		 mcp25xxfd_get_tef_tail(priv) == n ?
+		 (priv->tef.head == priv->tef.tail ? "  priv-FIFO-empty" : "  priv-FIFO-full") :
+		 ("")));
+	pr_info("%16s = 0x%08x\n", "id", hw_tef_obj->id);
+	pr_info("%16s = 0x%08x\n", "flags", hw_tef_obj->flags);
+	pr_info("%16s = 0x%08x\n", "ts", hw_tef_obj->ts);
+	__dump_mask(hw_tef_obj->flags, MCP25XXFD_OBJ_FLAGS, SEQ, "0x%06lx", "Sequence");
+	pr_info("\n");
+}
+
+static void mcp25xxfd_dump_ram_tef_obj(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_dump_ram *ram)
+{
+	int i;
+
+	pr_info("\nTEF Overview:\n");
+	pr_info("%16s =        0x%02x    0x%08x\n", "head (p)", mcp25xxfd_get_tef_head(priv), priv->tef.head);
+	pr_info("%16s = 0x%02x   0x%02x    0x%08x\n", "tail (c/p)", mcp25xxfd_dump_get_tef_tail(priv, regs), mcp25xxfd_get_tef_tail(priv), priv->tef.tail);
+	pr_info("\n");
+
+	for (i = 0; i < mcp25xxfd_dump_get_tef_obj_num(priv, regs); i++) {
+		const struct mcp25xxfd_hw_tef_obj *hw_tef_obj;
+		u16 hw_tef_obj_rel_addr;
+
+		hw_tef_obj_rel_addr = mcp25xxfd_dump_get_tef_obj_rel_addr(priv, i);
+
+		hw_tef_obj = (const struct mcp25xxfd_hw_tef_obj *)&ram->ram[hw_tef_obj_rel_addr];
+		mcp25xxfd_dump_ram_tef_obj_one(priv, regs, hw_tef_obj, i);
+	}
+}
+
+/* dump TX */
+
+static void mcp25xxfd_dump_ram_tx_obj_one(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_hw_tx_obj_canfd *hw_tx_obj, u8 n)
+{
+	pr_info("TX Object: 0x%02x (0x%03x)%s%s%s%s%s%s\n",
+		n, mcp25xxfd_dump_get_tx_obj_addr(priv, regs, n),
+		mcp25xxfd_dump_get_tx_head(priv, regs) == n ? "  chip-HEAD" : "",
+		mcp25xxfd_get_tx_head(priv) == n ? "  priv-HEAD" : "",
+		mcp25xxfd_dump_get_tx_tail(priv, regs) == n ? "  chip-TAIL" : "",
+		mcp25xxfd_get_tx_tail(priv) == n ? "  priv-TAIL" : "",
+		mcp25xxfd_dump_get_tx_tail(priv, regs) == n ?
+		(!(regs->tx_fifo.sta & MCP25XXFD_CAN_FIFOSTA_TFNRFNIF) ? "  chip-FIFO-full" :
+		 (regs->tx_fifo.sta & MCP25XXFD_CAN_FIFOSTA_TFERFFIF) ? "  chip-FIFO-empty" : "") :
+		(""),
+		(mcp25xxfd_get_tx_head(priv) == mcp25xxfd_get_tx_tail(priv) &&
+		 mcp25xxfd_get_tx_tail(priv) == n ?
+		 (priv->tx.head == priv->tx.tail ? "  priv-FIFO-empty" : "  priv-FIFO-full") :
+		 ("")));
+	pr_info("%16s = 0x%08x\n", "id", hw_tx_obj->id);
+	pr_info("%16s = 0x%08x\n", "flags", hw_tx_obj->flags);
+	__dump_mask(hw_tx_obj->flags, MCP25XXFD_OBJ_FLAGS, SEQ_MCP2517FD, "0x%06lx", "Sequence (MCP2517)");
+	__dump_mask(hw_tx_obj->flags, MCP25XXFD_OBJ_FLAGS, SEQ_MCP2518FD, "0x%06lx", "Sequence (MCP2518)");
+	mcp25xxfd_dump_ram_fifo_obj_data(priv, hw_tx_obj->data, FIELD_GET(MCP25XXFD_OBJ_FLAGS_DLC, hw_tx_obj->flags));
+	pr_info("\n");
+}
+
+static void mcp25xxfd_dump_ram_tx_obj(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_dump_ram *ram)
+{
+	int i;
+
+	pr_info("\nTX Overview:\n");
+	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "head (c/p)", mcp25xxfd_dump_get_tx_head(priv, regs), mcp25xxfd_get_tx_head(priv), priv->tx.head);
+	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "tail (c/p)", mcp25xxfd_dump_get_tx_tail(priv, regs), mcp25xxfd_get_tx_tail(priv), priv->tx.tail);
+	pr_info("\n");
+
+	for (i = 0; i < mcp25xxfd_dump_get_tx_obj_num(priv, regs); i++) {
+		const struct mcp25xxfd_hw_tx_obj_canfd *hw_tx_obj;
+		u16 hw_tx_obj_rel_addr;
+
+		hw_tx_obj_rel_addr = mcp25xxfd_dump_get_tx_obj_rel_addr(priv, regs, i);
+		hw_tx_obj = (const struct mcp25xxfd_hw_tx_obj_canfd *)&ram->ram[hw_tx_obj_rel_addr];
+
+		mcp25xxfd_dump_ram_tx_obj_one(priv, regs, hw_tx_obj, i);
+	}
+}
+
+/* dump RX */
+
+static void mcp25xxfd_dump_ram_rx_obj_one(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj, u8 n)
+{
+	pr_info("RX Object: 0x%02x (0x%03x)%s%s%s%s%s%s\n",
+		n, mcp25xxfd_dump_get_rx_obj_addr(priv, regs, n),
+		mcp25xxfd_dump_get_rx_head(priv, regs) == n ? "  chip-HEAD" : "",
+		mcp25xxfd_get_rx_head(priv) == n ? "  priv-HEAD" : "",
+		mcp25xxfd_dump_get_rx_tail(priv, regs) == n ? "  chip-TAIL" : "",
+		mcp25xxfd_get_rx_tail(priv) == n ? "  priv-TAIL" : "",
+		mcp25xxfd_dump_get_rx_tail(priv, regs) == n ?
+		((regs->rx_fifo.sta & MCP25XXFD_CAN_FIFOSTA_TFERFFIF) ? "  chip-FIFO-full" :
+		 !(regs->rx_fifo.sta & MCP25XXFD_CAN_FIFOSTA_TFNRFNIF) ? "  chip-FIFO-empty" : "") :
+		(""),
+		(mcp25xxfd_get_rx_head(priv) == mcp25xxfd_get_rx_tail(priv) &&
+		 mcp25xxfd_get_rx_tail(priv) == n ?
+		 (priv->rx.head == priv->rx.tail ? "  priv-FIFO-empty" : "  priv-FIFO-full") :
+		 ("")));
+	pr_info("%16s = 0x%08x\n", "id", hw_rx_obj->id);
+	pr_info("%16s = 0x%08x\n", "flags", hw_rx_obj->flags);
+	pr_info("%16s = 0x%08x\n", "ts", hw_rx_obj->ts);
+	mcp25xxfd_dump_ram_fifo_obj_data(priv, hw_rx_obj->data, FIELD_GET(MCP25XXFD_OBJ_FLAGS_DLC, hw_rx_obj->flags));
+	pr_info("\n");
+}
+
+static void mcp25xxfd_dump_ram_rx_obj(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_dump_ram *ram)
+{
+	int i;
+
+	pr_info("\nRX Overview:\n");
+	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "head (c/p)", mcp25xxfd_dump_get_rx_head(priv, regs), mcp25xxfd_get_rx_head(priv), priv->rx.head);
+	pr_info("%16s = 0x%02x    0x%02x    0x%08x\n", "tail (c/p)", mcp25xxfd_dump_get_rx_tail(priv, regs), mcp25xxfd_get_rx_tail(priv), priv->rx.tail);
+	pr_info("\n");
+
+	for (i = 0; i < mcp25xxfd_dump_get_rx_obj_num(priv, regs); i++) {
+		const struct mcp25xxfd_hw_rx_obj_canfd *hw_rx_obj;
+		u16 hw_rx_obj_rel_addr;
+
+		hw_rx_obj_rel_addr = mcp25xxfd_dump_get_rx_obj_rel_addr(priv, regs, i);
+		hw_rx_obj = (const struct mcp25xxfd_hw_rx_obj_canfd *)&ram->ram[hw_rx_obj_rel_addr];
+
+		mcp25xxfd_dump_ram_rx_obj_one(priv, regs, hw_rx_obj, i);
+	}
+}
+
+#undef __dump_mask
+#undef __dump_bit
+
+static void mcp25xxfd_dump_ram(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_dump_regs *regs, const struct mcp25xxfd_dump_ram *ram)
+{
+	netdev_info(priv->ndev, "----------------------- RAM dump ----------------------\n");
+	mcp25xxfd_dump_ram_tef_obj(priv, regs, ram);
+	mcp25xxfd_dump_ram_tx_obj(priv, regs, ram);
+	mcp25xxfd_dump_ram_rx_obj(priv, regs, ram);
+	netdev_info(priv->ndev, "------------------------- end -------------------------\n");
+}
+
+void mcp25xxfd_dump(struct mcp25xxfd_priv *priv)
+{
+	struct mcp25xxfd_dump_regs *regs = &priv->dump.regs;
+	struct mcp25xxfd_dump_ram *ram = &priv->dump.ram;
+	struct mcp25xxfd_dump_regs_mcp25xxfd *regs_mcp25xxfd = &priv->dump.regs_mcp25xxfd;
+	int err;
+
+	BUILD_BUG_ON(sizeof(struct mcp25xxfd_dump_regs) !=
+		     MCP25XXFD_CAN_FIFOUA(31) - MCP25XXFD_CAN_CON + 4);
+
+	err = regmap_bulk_read(priv->map, MCP25XXFD_CAN_CON,
+			       regs, sizeof(*regs) / sizeof(u32));
+	if (err)
+		return;
+
+	err = regmap_bulk_read(priv->map, MCP25XXFD_RAM_START,
+			       ram, sizeof(*ram) / sizeof(u32));
+	if (err)
+		return;
+
+	err = regmap_bulk_read(priv->map, MCP25XXFD_OSC,
+			       regs_mcp25xxfd, sizeof(*regs_mcp25xxfd) / sizeof(u32));
+	if (err)
+		return;
+
+	mcp25xxfd_dump_regs(priv, regs, regs_mcp25xxfd);
+	mcp25xxfd_dump_ram(priv, regs, ram);
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c
new file mode 100644
index 000000000000..d1a70513d5e4
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.c
@@ -0,0 +1,105 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+//
+// Copyright (c) 2019 Pengutronix,
+//                    Marc Kleine-Budde <kernel@pengutronix.de>
+//
+
+#include "mcp25xxfd.h"
+#include "mcp25xxfd-log.h"
+
+struct mcp25xxfd_log *___mcp25xxfd_log(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
+{
+	struct mcp25xxfd_log *log;
+	int cnt;
+
+	cnt = atomic_add_return(1, &priv->cnt);
+	cnt &= ARRAY_SIZE(priv->log) - 1;
+
+	log = &priv->log[cnt];
+	log->func = func;
+	log->can_id = can_id;
+	log->tef_head = priv->tef.head;
+	log->tef_tail = priv->tef.tail;
+	log->tx_head = priv->tx.head;
+	log->tx_tail = priv->tx.tail;
+	log->flags = 0;
+
+	return log;
+}
+
+static void mcp25xxfd_log_dump_one(const struct mcp25xxfd_priv *priv, const struct mcp25xxfd_log *last_log, const struct mcp25xxfd_log *log, int n)
+{
+	pr_info("%04d: %30s: ",
+		n, log->func);
+
+	if (log->can_id != -1 &&
+	    last_log->can_id != log->can_id)
+		pr_cont("id=%03x ", log->can_id);
+	else
+		pr_cont(" ---   ");
+
+	if (last_log->tef_head != log->tef_head)
+		pr_cont("tef_h=%08x/%02x ", log->tef_head, log->tef_head & (priv->tx.obj_num - 1));
+	else
+		pr_cont("    ---           ");
+
+	if (log->hw_tx_ci != -1 &&
+	    last_log->hw_tx_ci != log->hw_tx_ci)
+		pr_cont("hw_tx_ci=%02x ", log->hw_tx_ci);
+	else
+		pr_cont("       ---  ");
+
+	if (last_log->tef_tail != log->tef_tail)
+		pr_cont("tef_t=%08x/%02x ", log->tef_tail, log->tef_tail & (priv->tx.obj_num - 1));
+	else
+		pr_cont("    ---           ");
+
+	if (log->hw_tef_tail != -1 &&
+	    last_log->hw_tef_tail != log->hw_tef_tail)
+		pr_cont("hw_tef_t=%02x ", log->hw_tef_tail);
+	else
+		pr_cont("       ---  ");
+
+	if (last_log->tx_head != log->tx_head)
+		pr_cont("tx_h=%08x/%02x ", log->tx_head, log->tx_head & (priv->tx.obj_num - 1));
+	else
+		pr_cont("   ---           ");
+
+	if (last_log->tx_tail != log->tx_tail)
+		pr_cont("tx_t=%08x/%02x ", log->tx_tail, log->tx_tail & (priv->tx.obj_num - 1));
+	else
+		pr_cont("   ---           ");
+
+	pr_cont("%s%s%s\n",
+		log->flags & MCP25XXFD_LOG_STOP ? "s" : " ",
+		log->flags & MCP25XXFD_LOG_WAKE ? "w" : " ",
+		log->flags & MCP25XXFD_LOG_BUSY ? "b" : " ");
+}
+
+void mcp25xxfd_log_dump(const struct mcp25xxfd_priv *priv)
+{
+	int cnt;
+	int i, n = 0;
+
+	cnt = atomic_read(&priv->cnt);
+	cnt &= ARRAY_SIZE(priv->log) - 1;
+
+	i = cnt;
+
+	if (cnt == 0) {
+		mcp25xxfd_log_dump_one(priv, &priv->log[ARRAY_SIZE(priv->log) - 2], &priv->log[0], n++);
+		i++;
+	}
+
+	for (/* nix */; i < ARRAY_SIZE(priv->log); i++)
+		mcp25xxfd_log_dump_one(priv, &priv->log[i - 1], &priv->log[i], n++);
+
+	if (cnt) {
+		mcp25xxfd_log_dump_one(priv, &priv->log[ARRAY_SIZE(priv->log) - 2], &priv->log[0], n++);
+		if (cnt > 1)
+			for (i = 1; i < cnt; i++)
+				mcp25xxfd_log_dump_one(priv, &priv->log[i - 1], &priv->log[i], n++);
+	}
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h
new file mode 100644
index 000000000000..cadb07780ee1
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-log.h
@@ -0,0 +1,164 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+ *
+ * Copyright (c) 2019 Pengutronix,
+ *                    Marc Kleine-Budde <kernel@pengutronix.de>
+ */
+
+#ifndef _MCP25XXFD_LOG_H
+#define _MCP25XXFD_LOG_H
+
+struct mcp25xxfd_priv;
+
+#ifdef CONFIG_CAN_MCP25XXFD_LOG
+
+struct mcp25xxfd_log {
+	const char *func;
+	canid_t can_id;
+	u32 tef_head;
+	u32 tef_tail;
+	u32 tx_head;
+	u32 tx_tail;
+
+#define MCP25XXFD_LOG_STOP BIT(0)
+#define MCP25XXFD_LOG_WAKE BIT(1)
+#define MCP25XXFD_LOG_BUSY BIT(2)
+	u32 flags;
+
+	u32 hw_tx_ci;
+	u32 hw_tef_tail;
+};
+
+struct mcp25xxfd_log *___mcp25xxfd_log(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id);
+void mcp25xxfd_log_dump(const struct mcp25xxfd_priv *priv);
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
+{
+	struct mcp25xxfd_log *log;
+
+	log = ___mcp25xxfd_log(priv, func, can_id);
+	log->hw_tx_ci = -1;
+	log->hw_tef_tail = -1;
+
+	return log;
+}
+
+#define mcp25xxfd_log(priv, ...) __mcp25xxfd_log(priv, __func__, ## __VA_ARGS__)
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log_no_canid(struct mcp25xxfd_priv *priv, const char *func)
+{
+	struct mcp25xxfd_log *log;
+
+	log = __mcp25xxfd_log(priv, func, -1);
+	log->can_id = -1;
+
+	return log;
+}
+
+#define mcp25xxfd_log_no_canid(priv, ...) __mcp25xxfd_log_no_canid(priv, __func__, ## __VA_ARGS__)
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log_stop(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
+{
+	struct mcp25xxfd_log *log;
+
+	log = __mcp25xxfd_log(priv, func, can_id);
+	log->flags |= MCP25XXFD_LOG_STOP;
+
+	return log;
+}
+
+#define mcp25xxfd_log_stop(priv, ...) __mcp25xxfd_log_stop(priv, __func__, ## __VA_ARGS__)
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log_wake(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
+{
+	struct mcp25xxfd_log *log;
+
+	log = __mcp25xxfd_log(priv, func, can_id);
+	log->flags |= MCP25XXFD_LOG_WAKE;
+
+	return log;
+}
+
+#define mcp25xxfd_log_wake(priv, ...) __mcp25xxfd_log_wake(priv, __func__, ## __VA_ARGS__)
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log_busy(struct mcp25xxfd_priv *priv, const char *func, canid_t can_id)
+{
+	struct mcp25xxfd_log *log;
+
+	log = __mcp25xxfd_log(priv, func, can_id);
+	log->flags |= MCP25XXFD_LOG_BUSY;
+
+	return log;
+}
+
+#define mcp25xxfd_log_busy(priv, ...) __mcp25xxfd_log_busy(priv, __func__, ## __VA_ARGS__)
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log_hw_tx_ci(struct mcp25xxfd_priv *priv, const char *func, u32 tx_ci)
+{
+	struct mcp25xxfd_log *log;
+
+	log = __mcp25xxfd_log_no_canid(priv, func);
+	log->hw_tx_ci = tx_ci;
+
+	return log;
+}
+
+#define mcp25xxfd_log_hw_tx_ci(priv, ...) __mcp25xxfd_log_hw_tx_ci(priv, __func__, ## __VA_ARGS__)
+
+static inline struct mcp25xxfd_log *__mcp25xxfd_log_hw_tef_tail(struct mcp25xxfd_priv *priv, const char *func, u32 tef_tail)
+{
+	struct mcp25xxfd_log *log;
+
+	log = __mcp25xxfd_log_no_canid(priv, func);
+	log->hw_tef_tail = tef_tail;
+
+	return log;
+}
+
+#define mcp25xxfd_log_hw_tef_tail(priv, ...) __mcp25xxfd_log_hw_tef_tail(priv, __func__, ## __VA_ARGS__)
+
+#else
+
+static inline void mcp25xxfd_log_dump(const struct mcp25xxfd_priv *priv)
+{
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log(struct mcp25xxfd_priv *priv, canid_t can_id)
+{
+	return NULL;
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log_no_canid(struct mcp25xxfd_priv *priv)
+{
+	return NULL;
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log_stop(struct mcp25xxfd_priv *priv, canid_t can_id)
+{
+	return NULL;
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log_wake(struct mcp25xxfd_priv *priv, canid_t can_id)
+{
+	return NULL;
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log_busy(struct mcp25xxfd_priv *priv, canid_t can_id)
+{
+	return NULL;
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log_hw_tx_ci(struct mcp25xxfd_priv *priv, u32 tx_ci)
+{
+	return NULL;
+}
+
+static inline struct mcp25xxfd_log *mcp25xxfd_log_hw_tef_tail(struct mcp25xxfd_priv *priv, u32 tef_tail)
+{
+	return NULL;
+}
+
+#endif
+
+#endif
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c
new file mode 100644
index 000000000000..c2628653d48c
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd-regmap.c
@@ -0,0 +1,268 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+//
+// Copyright (c) 2019, 2020 Pengutronix,
+//                          Marc Kleine-Budde <kernel@pengutronix.de>
+//
+
+#include "mcp25xxfd.h"
+
+static int mcp25xxfd_regmap_write(void *context, const void *data, size_t count)
+{
+	struct spi_device *spi = context;
+
+	return spi_write(spi, data, count);
+}
+
+static int mcp25xxfd_regmap_gather_write(void *context,
+					 const void *reg, size_t reg_len,
+					 const void *val, size_t val_len)
+{
+	struct spi_device *spi = context;
+	struct spi_transfer xfer[] = {
+		{
+			.tx_buf = reg,
+			.len = reg_len,
+		}, {
+			.tx_buf = val,
+			.len = val_len,
+		},
+	};
+
+	return spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
+}
+
+static inline bool mcp25xxfd_update_bits_read_reg(unsigned int reg)
+{
+	switch (reg) {
+	case MCP25XXFD_CAN_INT:
+	case MCP25XXFD_CAN_TEFCON:
+	case MCP25XXFD_CAN_FIFOCON(MCP25XXFD_RX_FIFO(0)):
+	case MCP25XXFD_ECCSTAT:
+	case MCP25XXFD_CRC:
+		return false;
+	case MCP25XXFD_CAN_BDIAG1:
+	case MCP25XXFD_CAN_CON:
+	case MCP25XXFD_CAN_FIFOSTA(MCP25XXFD_RX_FIFO(0)):
+	case MCP25XXFD_OSC:
+		return true;
+	default:
+		WARN(1, "Status of reg=%03x unknown.\n", reg);
+	}
+
+	return true;
+}
+
+static int mcp25xxfd_regmap_update_bits(void *context, unsigned int reg,
+					unsigned int mask, unsigned int val)
+
+{
+	struct spi_device *spi = context;
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+	struct mcp25xxfd_reg_write_buf *buf = &priv->update_bits_buf;
+	__be16 cmd;
+	__le32 orig_le32 = 0, mask_le32, val_le32, tmp_le32;
+	u8 first_byte, last_byte, len;
+	int err;
+
+	first_byte = mcp25xxfd_first_byte_set(mask);
+	last_byte = mcp25xxfd_last_byte_set(mask);
+	len = last_byte - first_byte + 1;
+
+	if (mcp25xxfd_update_bits_read_reg(reg)) {
+		cmd = mcp25xxfd_cmd_read(reg + first_byte);
+		/* spi_write_then_read() works with non DMA-safe buffers */
+		err = spi_write_then_read(priv->spi,
+					  &cmd, sizeof(cmd), &orig_le32, len);
+
+		if (err)
+			return err;
+	}
+
+	mask_le32 = cpu_to_le32(mask >> 8 * first_byte);
+	val_le32 = cpu_to_le32(val >> 8 * first_byte);
+
+	tmp_le32 = orig_le32 & ~mask_le32;
+	tmp_le32 |= val_le32 & mask_le32;
+
+	buf->cmd = mcp25xxfd_cmd_write(reg + first_byte);
+	memcpy(buf->data, &tmp_le32, len);
+
+	return spi_write(spi, buf, sizeof(buf->cmd) + len);
+}
+
+static int mcp25xxfd_regmap_read(void *context,
+				 const void *reg, size_t reg_len,
+				 void *val_buf, size_t val_len)
+{
+	struct spi_device *spi = context;
+	struct spi_transfer xfer[] = {
+		{
+			.tx_buf = reg,
+			.len = reg_len,
+		}, {
+			.rx_buf = val_buf,
+			.len = val_len,
+		},
+	};
+
+	return spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
+}
+
+static int mcp25xxfd_regmap_crc_gather_write(void *context,
+					     const void *reg, size_t reg_len,
+					     const void *val, size_t val_len)
+{
+	struct spi_device *spi = context;
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+	struct spi_transfer xfer[] = {
+		{
+			.tx_buf = &priv->crc_buf.addr,
+			.len = sizeof(priv->crc_buf.addr),
+		}, {
+			.tx_buf = val,
+			.len = val_len,
+		}, {
+			.rx_buf = &priv->crc_buf.crc,
+			.len = sizeof(priv->crc_buf.crc),
+		},
+	};
+	u16 crc;
+
+	priv->crc_buf.addr.cmd = *(__be16 *)reg;
+	priv->crc_buf.addr.len = val_len;
+
+	crc = mcp25xxfd_crc16_compute(xfer[0].tx_buf, xfer[0].len,
+				      xfer[1].rx_buf, xfer[1].len);
+	priv->crc_buf.crc = cpu_to_be16(crc);
+
+	return spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
+}
+
+static int mcp25xxfd_regmap_crc_write(void *context,
+				      const void *data, size_t count)
+{
+	struct spi_device *spi = context;
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+
+	return mcp25xxfd_regmap_crc_gather_write(context, data,
+						 sizeof(priv->crc_buf.addr),
+						 data + 4, count - 4);
+}
+
+static int mcp25xxfd_regmap_crc_read(void *context,
+				     const void *reg, size_t reg_len,
+				     void *val_buf, size_t val_len)
+{
+	struct spi_device *spi = context;
+	struct mcp25xxfd_priv *priv = spi_get_drvdata(spi);
+	struct spi_transfer xfer[] = {
+		{
+			.tx_buf = &priv->crc_buf.addr,
+			.len = sizeof(priv->crc_buf.addr),
+		}, {
+			.rx_buf = val_buf,
+			.len = val_len,
+		}, {
+			.rx_buf = &priv->crc_buf.crc,
+			.len = sizeof(priv->crc_buf.crc),
+		},
+	};
+	u16 crc_received, crc_calculated;
+	int err;
+
+	priv->crc_buf.addr.cmd = *(__be16 *)reg;
+	priv->crc_buf.addr.len = val_len;
+
+	err = spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));
+	if (err)
+		return err;
+
+	crc_received = be16_to_cpu(priv->crc_buf.crc);
+	crc_calculated = mcp25xxfd_crc16_compute(xfer[0].tx_buf, xfer[0].len,
+						 xfer[1].rx_buf, xfer[1].len);
+	if (crc_received != crc_calculated) {
+		__dump(xfer[0].tx_buf, xfer[0].len);
+		__dump(xfer[1].rx_buf, xfer[1].len);
+		__dump(&crc_received, sizeof(crc_received));
+		__dump(&crc_calculated, sizeof(crc_calculated));
+		return -EBADMSG;
+	}
+
+	return 0;
+}
+
+static const struct regmap_range mcp25xxfd_reg_table_yes_range[] = {
+	regmap_reg_range(0x000, 0x2ec),	/* CAN FD Controller Module SFR */
+	regmap_reg_range(0x400, 0xbfc),	/* RAM */
+	regmap_reg_range(0xe00, 0xe14),	/* MCP2517/18FD SFR */
+};
+
+static const struct regmap_access_table mcp25xxfd_reg_table = {
+	.yes_ranges = mcp25xxfd_reg_table_yes_range,
+	.n_yes_ranges = ARRAY_SIZE(mcp25xxfd_reg_table_yes_range),
+};
+
+static const struct regmap_config mcp25xxfd_regmap = {
+	.reg_bits = 16,
+	.reg_stride = 4,
+	.pad_bits = 0,
+	.val_bits = 32,
+	.max_register = 0xffc,
+	.wr_table = &mcp25xxfd_reg_table,
+	.rd_table = &mcp25xxfd_reg_table,
+	.cache_type = REGCACHE_NONE,
+	.read_flag_mask = (__force unsigned long)
+		cpu_to_be16(MCP25XXFD_INSTRUCTION_READ),
+	.write_flag_mask = (__force unsigned long)
+		cpu_to_be16(MCP25XXFD_INSTRUCTION_WRITE),
+};
+
+static const struct regmap_bus mcp25xxfd_bus = {
+	.write = mcp25xxfd_regmap_write,
+	.gather_write = mcp25xxfd_regmap_gather_write,
+	.reg_update_bits = mcp25xxfd_regmap_update_bits,
+	.read = mcp25xxfd_regmap_read,
+	.reg_format_endian_default = REGMAP_ENDIAN_BIG,
+	.val_format_endian_default = REGMAP_ENDIAN_LITTLE,
+};
+
+static const struct regmap_config mcp25xxfd_regmap_crc = {
+	.name = "crc",
+	.reg_bits = 16,
+	.reg_stride = 4,
+	.pad_bits = 16,		/* keep data bits aligned */
+	.val_bits = 32,
+	.max_register = 0xffc,
+	.wr_table = &mcp25xxfd_reg_table,
+	.rd_table = &mcp25xxfd_reg_table,
+	.cache_type = REGCACHE_NONE,
+	.read_flag_mask = (__force unsigned long)
+		cpu_to_be16(MCP25XXFD_INSTRUCTION_READ_CRC),
+	.write_flag_mask = (__force unsigned long)
+		cpu_to_be16(MCP25XXFD_INSTRUCTION_WRITE_CRC),
+};
+
+static const struct regmap_bus mcp25xxfd_bus_crc = {
+	.write = mcp25xxfd_regmap_crc_write,
+	.gather_write = mcp25xxfd_regmap_crc_gather_write,
+	.read = mcp25xxfd_regmap_crc_read,
+	.reg_format_endian_default = REGMAP_ENDIAN_BIG,
+	.val_format_endian_default = REGMAP_ENDIAN_LITTLE,
+	.max_raw_read = 256 - 4,
+	.max_raw_write = 256 - 4,
+};
+
+int mcp25xxfd_regmap_init(struct mcp25xxfd_priv *priv)
+{
+	priv->map = devm_regmap_init(&priv->spi->dev, &mcp25xxfd_bus,
+				     priv->spi, &mcp25xxfd_regmap);
+	if (IS_ERR(priv->map))
+		return PTR_ERR(priv->map);
+
+	priv->map_crc = devm_regmap_init(&priv->spi->dev, &mcp25xxfd_bus_crc,
+					 priv->spi, &mcp25xxfd_regmap_crc);
+	return PTR_ERR_OR_ZERO(priv->map_crc);
+
+}
diff --git a/drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h
new file mode 100644
index 000000000000..67694e8dbc6c
--- /dev/null
+++ b/drivers/net/can/spi/mcp25xxfd/mcp25xxfd.h
@@ -0,0 +1,758 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * mcp25xxfd - Microchip MCP25xxFD Family CAN controller driver
+ *
+ * Copyright (c) 2019 Pengutronix,
+ *                    Marc Kleine-Budde <kernel@pengutronix.de>
+ * Copyright (c) 2019 Martin Sperl <kernel@martin.sperl.org>
+ */
+
+#ifndef _MCP25XXFD_H
+#define _MCP25XXFD_H
+
+#include <linux/can/core.h>
+#include <linux/can/dev.h>
+#include <linux/can/rx-offload.h>
+#include <linux/gpio/consumer.h>
+#include <linux/kernel.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/spi/spi.h>
+
+#include "mcp25xxfd-log.h"
+
+static inline void __dump(const void *d, unsigned int len)
+{
+	const u8 *data = d;
+	unsigned int i;
+
+	for (i = 0; i < len; i++) {
+		if ((i % 8) == 0) {
+			if (i == 0)
+				pr_info("%16s = %02x", "data", data[i]);
+			else
+				pr_info("                   %02x", data[i]);
+		} else if ((i % 4) == 0) {
+			pr_cont("  %02x", data[i]);
+		} else if ((i % 8) == 7) {
+			pr_cont(" %02x\n", data[i]);
+		} else {
+			pr_cont(" %02x", data[i]);
+		}
+	}
+
+	if (i % 8)
+		pr_cont("\n");
+}
+
+/* MPC25xx registers */
+
+/* CAN FD Controller Module SFR */
+#define MCP25XXFD_CAN_CON 0x00
+#define MCP25XXFD_CAN_CON_TXBWS_MASK GENMASK(31, 28)
+#define MCP25XXFD_CAN_CON_ABAT BIT(27)
+#define MCP25XXFD_CAN_CON_REQOP_MASK GENMASK(26, 24)
+#define MCP25XXFD_CAN_CON_MODE_MIXED 0
+#define MCP25XXFD_CAN_CON_MODE_SLEEP 1
+#define MCP25XXFD_CAN_CON_MODE_INT_LOOPBACK 2
+#define MCP25XXFD_CAN_CON_MODE_LISTENONLY 3
+#define MCP25XXFD_CAN_CON_MODE_CONFIG 4
+#define MCP25XXFD_CAN_CON_MODE_EXT_LOOPBACK 5
+#define MCP25XXFD_CAN_CON_MODE_CAN2_0 6
+#define MCP25XXFD_CAN_CON_MODE_RESTRICTED 7
+#define MCP25XXFD_CAN_CON_OPMOD_MASK GENMASK(23, 21)
+#define MCP25XXFD_CAN_CON_TXQEN BIT(20)
+#define MCP25XXFD_CAN_CON_STEF BIT(19)
+#define MCP25XXFD_CAN_CON_SERR2LOM BIT(18)
+#define MCP25XXFD_CAN_CON_ESIGM BIT(17)
+#define MCP25XXFD_CAN_CON_RTXAT BIT(16)
+#define MCP25XXFD_CAN_CON_BRSDIS BIT(12)
+#define MCP25XXFD_CAN_CON_BUSY BIT(11)
+#define MCP25XXFD_CAN_CON_WFT_MASK GENMASK(10, 9)
+#define MCP25XXFD_CAN_CON_WFT_T00FILTER 0x0
+#define MCP25XXFD_CAN_CON_WFT_T01FILTER 0x1
+#define MCP25XXFD_CAN_CON_WFT_T10FILTER 0x2
+#define MCP25XXFD_CAN_CON_WFT_T11FILTER 0x3
+#define MCP25XXFD_CAN_CON_WAKFIL BIT(8)
+#define MCP25XXFD_CAN_CON_PXEDIS BIT(6)
+#define MCP25XXFD_CAN_CON_ISOCRCEN BIT(5)
+#define MCP25XXFD_CAN_CON_DNCNT_MASK GENMASK(4, 0)
+
+#define MCP25XXFD_CAN_NBTCFG 0x04
+#define MCP25XXFD_CAN_NBTCFG_BRP_MASK GENMASK(31, 24)
+#define MCP25XXFD_CAN_NBTCFG_TSEG1_MASK GENMASK(23, 16)
+#define MCP25XXFD_CAN_NBTCFG_TSEG2_MASK GENMASK(14, 8)
+#define MCP25XXFD_CAN_NBTCFG_SJW_MASK GENMASK(6, 0)
+
+#define MCP25XXFD_CAN_DBTCFG 0x08
+#define MCP25XXFD_CAN_DBTCFG_BRP_MASK GENMASK(31, 24)
+#define MCP25XXFD_CAN_DBTCFG_TSEG1_MASK GENMASK(20, 16)
+#define MCP25XXFD_CAN_DBTCFG_TSEG2_MASK GENMASK(11, 8)
+#define MCP25XXFD_CAN_DBTCFG_SJW_MASK GENMASK(3, 0)
+
+#define MCP25XXFD_CAN_TDC 0x0c
+#define MCP25XXFD_CAN_TDC_EDGFLTEN BIT(25)
+#define MCP25XXFD_CAN_TDC_SID11EN BIT(24)
+#define MCP25XXFD_CAN_TDC_TDCMOD_MASK GENMASK(17, 16)
+#define MCP25XXFD_CAN_TDC_TDCMOD_AUTO 2
+#define MCP25XXFD_CAN_TDC_TDCMOD_MANUAL 1
+#define MCP25XXFD_CAN_TDC_TDCMOD_DISABLED 0
+#define MCP25XXFD_CAN_TDC_TDCO_MASK GENMASK(14, 8)
+#define MCP25XXFD_CAN_TDC_TDCV_MASK GENMASK(5, 0)
+
+#define MCP25XXFD_CAN_TBC 0x10
+
+#define MCP25XXFD_CAN_TSCON 0x14
+#define MCP25XXFD_CAN_TSCON_TSRES BIT(18)
+#define MCP25XXFD_CAN_TSCON_TSEOF BIT(17)
+#define MCP25XXFD_CAN_TSCON_TBCEN BIT(16)
+#define MCP25XXFD_CAN_TSCON_TBCPRE_MASK GENMASK(9, 0)
+
+#define MCP25XXFD_CAN_VEC 0x18
+#define MCP25XXFD_CAN_VEC_RXCODE_MASK GENMASK(30, 24)
+#define MCP25XXFD_CAN_VEC_TXCODE_MASK GENMASK(22, 16)
+#define MCP25XXFD_CAN_VEC_FILHIT_MASK GENMASK(12, 8)
+#define MCP25XXFD_CAN_VEC_ICODE_MASK GENMASK(6, 0)
+
+#define MCP25XXFD_CAN_INT 0x1c
+#define MCP25XXFD_CAN_INT_IF_MASK GENMASK(15, 0)
+#define MCP25XXFD_CAN_INT_IE_MASK GENMASK(31, 16)
+#define MCP25XXFD_CAN_INT_IVMIE BIT(31)
+#define MCP25XXFD_CAN_INT_WAKIE BIT(30)
+#define MCP25XXFD_CAN_INT_CERRIE BIT(29)
+#define MCP25XXFD_CAN_INT_SERRIE BIT(28)
+#define MCP25XXFD_CAN_INT_RXOVIE BIT(27)
+#define MCP25XXFD_CAN_INT_TXATIE BIT(26)
+#define MCP25XXFD_CAN_INT_SPICRCIE BIT(25)
+#define MCP25XXFD_CAN_INT_ECCIE BIT(24)
+#define MCP25XXFD_CAN_INT_TEFIE BIT(20)
+#define MCP25XXFD_CAN_INT_MODIE BIT(19)
+#define MCP25XXFD_CAN_INT_TBCIE BIT(18)
+#define MCP25XXFD_CAN_INT_RXIE BIT(17)
+#define MCP25XXFD_CAN_INT_TXIE BIT(16)
+#define MCP25XXFD_CAN_INT_IVMIF BIT(15)
+#define MCP25XXFD_CAN_INT_WAKIF BIT(14)
+#define MCP25XXFD_CAN_INT_CERRIF BIT(13)
+#define MCP25XXFD_CAN_INT_SERRIF BIT(12)
+#define MCP25XXFD_CAN_INT_RXOVIF BIT(11)
+#define MCP25XXFD_CAN_INT_TXATIF BIT(10)
+#define MCP25XXFD_CAN_INT_SPICRCIF BIT(9)
+#define MCP25XXFD_CAN_INT_ECCIF BIT(8)
+#define MCP25XXFD_CAN_INT_TEFIF BIT(4)
+#define MCP25XXFD_CAN_INT_MODIF BIT(3)
+#define MCP25XXFD_CAN_INT_TBCIF BIT(2)
+#define MCP25XXFD_CAN_INT_RXIF BIT(1)
+#define MCP25XXFD_CAN_INT_TXIF BIT(0)
+/* These IRQ flags must be cleared by SW in the CAN_INT register */
+#define MCP25XXFD_CAN_INT_IF_CLEARABLE_MASK \
+	(MCP25XXFD_CAN_INT_IVMIF | MCP25XXFD_CAN_INT_WAKIF | \
+	 MCP25XXFD_CAN_INT_CERRIF |  MCP25XXFD_CAN_INT_SERRIF | \
+	 MCP25XXFD_CAN_INT_MODIF)
+
+#define MCP25XXFD_CAN_RXIF 0x20
+#define MCP25XXFD_CAN_TXIF 0x24
+#define MCP25XXFD_CAN_RXOVIF 0x28
+#define MCP25XXFD_CAN_TXATIF 0x2c
+#define MCP25XXFD_CAN_TXREQ 0x30
+
+#define MCP25XXFD_CAN_TREC 0x34
+#define MCP25XXFD_CAN_TREC_TXBO BIT(21)
+#define MCP25XXFD_CAN_TREC_TXBP BIT(20)
+#define MCP25XXFD_CAN_TREC_RXBP BIT(19)
+#define MCP25XXFD_CAN_TREC_TXWARN BIT(18)
+#define MCP25XXFD_CAN_TREC_RXWARN BIT(17)
+#define MCP25XXFD_CAN_TREC_EWARN BIT(16)
+#define MCP25XXFD_CAN_TREC_TEC_MASK GENMASK(15, 8)
+#define MCP25XXFD_CAN_TREC_REC_MASK GENMASK(7, 0)
+
+#define MCP25XXFD_CAN_BDIAG0 0x38
+#define MCP25XXFD_CAN_BDIAG0_DTERRCNT_MASK GENMASK(31, 24)
+#define MCP25XXFD_CAN_BDIAG0_DRERRCNT_MASK GENMASK(23, 16)
+#define MCP25XXFD_CAN_BDIAG0_NTERRCNT_MASK GENMASK(15, 8)
+#define MCP25XXFD_CAN_BDIAG0_NRERRCNT_MASK GENMASK(7, 0)
+
+#define MCP25XXFD_CAN_BDIAG1 0x3c
+#define MCP25XXFD_CAN_BDIAG1_DLCMM BIT(31)
+#define MCP25XXFD_CAN_BDIAG1_ESI BIT(30)
+#define MCP25XXFD_CAN_BDIAG1_DCRCERR BIT(29)
+#define MCP25XXFD_CAN_BDIAG1_DSTUFERR BIT(28)
+#define MCP25XXFD_CAN_BDIAG1_DFORMERR BIT(27)
+#define MCP25XXFD_CAN_BDIAG1_DBIT1ERR BIT(25)
+#define MCP25XXFD_CAN_BDIAG1_DBIT0ERR BIT(24)
+#define MCP25XXFD_CAN_BDIAG1_TXBOERR BIT(23)
+#define MCP25XXFD_CAN_BDIAG1_NCRCERR BIT(21)
+#define MCP25XXFD_CAN_BDIAG1_NSTUFERR BIT(20)
+#define MCP25XXFD_CAN_BDIAG1_NFORMERR BIT(19)
+#define MCP25XXFD_CAN_BDIAG1_NACKERR BIT(18)
+#define MCP25XXFD_CAN_BDIAG1_NBIT1ERR BIT(17)
+#define MCP25XXFD_CAN_BDIAG1_NBIT0ERR BIT(16)
+#define MCP25XXFD_CAN_BDIAG1_BERR_MASK \
+	(MCP25XXFD_CAN_BDIAG1_DLCMM | MCP25XXFD_CAN_BDIAG1_ESI | \
+	 MCP25XXFD_CAN_BDIAG1_DCRCERR | MCP25XXFD_CAN_BDIAG1_DSTUFERR | \
+	 MCP25XXFD_CAN_BDIAG1_DFORMERR | MCP25XXFD_CAN_BDIAG1_DBIT1ERR | \
+	 MCP25XXFD_CAN_BDIAG1_DBIT0ERR | MCP25XXFD_CAN_BDIAG1_TXBOERR | \
+	 MCP25XXFD_CAN_BDIAG1_NCRCERR | MCP25XXFD_CAN_BDIAG1_NSTUFERR | \
+	 MCP25XXFD_CAN_BDIAG1_NFORMERR | MCP25XXFD_CAN_BDIAG1_NACKERR | \
+	 MCP25XXFD_CAN_BDIAG1_NBIT1ERR | MCP25XXFD_CAN_BDIAG1_NBIT0ERR)
+#define MCP25XXFD_CAN_BDIAG1_EFMSGCNT_MASK GENMASK(15, 0)
+
+#define MCP25XXFD_CAN_TEFCON 0x40
+#define MCP25XXFD_CAN_TEFCON_FSIZE_MASK GENMASK(28, 24)
+#define MCP25XXFD_CAN_TEFCON_FRESET BIT(10)
+#define MCP25XXFD_CAN_TEFCON_UINC BIT(8)
+#define MCP25XXFD_CAN_TEFCON_TEFTSEN BIT(5)
+#define MCP25XXFD_CAN_TEFCON_TEFOVIE BIT(3)
+#define MCP25XXFD_CAN_TEFCON_TEFFIE BIT(2)
+#define MCP25XXFD_CAN_TEFCON_TEFHIE BIT(1)
+#define MCP25XXFD_CAN_TEFCON_TEFNEIE BIT(0)
+
+#define MCP25XXFD_CAN_TEFSTA 0x44
+#define MCP25XXFD_CAN_TEFSTA_TEFOVIF BIT(3)
+#define MCP25XXFD_CAN_TEFSTA_TEFFIF BIT(2)
+#define MCP25XXFD_CAN_TEFSTA_TEFHIF BIT(1)
+#define MCP25XXFD_CAN_TEFSTA_TEFNEIF BIT(0)
+
+#define MCP25XXFD_CAN_TEFUA 0x48
+
+#define MCP25XXFD_CAN_TXQCON 0x50
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_MASK GENMASK(31, 29)
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_8 0
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_12 1
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_16 2
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_20 3
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_24 4
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_32 5
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_48 6
+#define MCP25XXFD_CAN_TXQCON_PLSIZE_64 7
+#define MCP25XXFD_CAN_TXQCON_FSIZE_MASK GENMASK(28, 24)
+#define MCP25XXFD_CAN_TXQCON_TXAT_UNLIMITED 3
+#define MCP25XXFD_CAN_TXQCON_TXAT_THREE_SHOT 1
+#define MCP25XXFD_CAN_TXQCON_TXAT_ONE_SHOT 0
+#define MCP25XXFD_CAN_TXQCON_TXAT_MASK GENMASK(22, 21)
+#define MCP25XXFD_CAN_TXQCON_TXPRI_MASK GENMASK(20, 16)
+#define MCP25XXFD_CAN_TXQCON_FRESET BIT(10)
+#define MCP25XXFD_CAN_TXQCON_TXREQ BIT(9)
+#define MCP25XXFD_CAN_TXQCON_UINC BIT(8)
+#define MCP25XXFD_CAN_TXQCON_TXEN BIT(7)
+#define MCP25XXFD_CAN_TXQCON_TXATIE BIT(4)
+#define MCP25XXFD_CAN_TXQCON_TXQEIE BIT(2)
+#define MCP25XXFD_CAN_TXQCON_TXQNIE BIT(0)
+
+#define MCP25XXFD_CAN_TXQSTA 0x54
+#define MCP25XXFD_CAN_TXQSTA_TXQCI_MASK GENMASK(12, 8)
+#define MCP25XXFD_CAN_TXQSTA_TXABT BIT(7)
+#define MCP25XXFD_CAN_TXQSTA_TXLARB BIT(6)
+#define MCP25XXFD_CAN_TXQSTA_TXERR BIT(5)
+#define MCP25XXFD_CAN_TXQSTA_TXATIF BIT(4)
+#define MCP25XXFD_CAN_TXQSTA_TXQEIF BIT(2)
+#define MCP25XXFD_CAN_TXQSTA_TXQNIF BIT(0)
+
+#define MCP25XXFD_CAN_TXQUA 0x58
+
+#define MCP25XXFD_CAN_FIFOCON(x) (0x50 + 0xc * (x))
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_MASK GENMASK(31, 29)
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_8 0
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_12 1
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_16 2
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_20 3
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_24 4
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_32 5
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_48 6
+#define MCP25XXFD_CAN_FIFOCON_PLSIZE_64 7
+#define MCP25XXFD_CAN_FIFOCON_FSIZE_MASK GENMASK(28, 24)
+#define MCP25XXFD_CAN_FIFOCON_TXAT_MASK GENMASK(22, 21)
+#define MCP25XXFD_CAN_FIFOCON_TXAT_ONE_SHOT 0
+#define MCP25XXFD_CAN_FIFOCON_TXAT_THREE_SHOT 1
+#define MCP25XXFD_CAN_FIFOCON_TXAT_UNLIMITED 3
+#define MCP25XXFD_CAN_FIFOCON_TXPRI_MASK GENMASK(20, 16)
+#define MCP25XXFD_CAN_FIFOCON_FRESET BIT(10)
+#define MCP25XXFD_CAN_FIFOCON_TXREQ BIT(9)
+#define MCP25XXFD_CAN_FIFOCON_UINC BIT(8)
+#define MCP25XXFD_CAN_FIFOCON_TXEN BIT(7)
+#define MCP25XXFD_CAN_FIFOCON_RTREN BIT(6)
+#define MCP25XXFD_CAN_FIFOCON_RXTSEN BIT(5)
+#define MCP25XXFD_CAN_FIFOCON_TXATIE BIT(4)
+#define MCP25XXFD_CAN_FIFOCON_RXOVIE BIT(3)
+#define MCP25XXFD_CAN_FIFOCON_TFERFFIE BIT(2)
+#define MCP25XXFD_CAN_FIFOCON_TFHRFHIE BIT(1)
+#define MCP25XXFD_CAN_FIFOCON_TFNRFNIE BIT(0)
+
+#define MCP25XXFD_CAN_FIFOSTA(x) (0x54 + 0xc * (x))
+#define MCP25XXFD_CAN_FIFOSTA_FIFOCI_MASK GENMASK(12, 8)
+#define MCP25XXFD_CAN_FIFOSTA_TXABT BIT(7)
+#define MCP25XXFD_CAN_FIFOSTA_TXLARB BIT(6)
+#define MCP25XXFD_CAN_FIFOSTA_TXERR BIT(5)
+#define MCP25XXFD_CAN_FIFOSTA_TXATIF BIT(4)
+#define MCP25XXFD_CAN_FIFOSTA_RXOVIF BIT(3)
+#define MCP25XXFD_CAN_FIFOSTA_TFERFFIF BIT(2)
+#define MCP25XXFD_CAN_FIFOSTA_TFHRFHIF BIT(1)
+#define MCP25XXFD_CAN_FIFOSTA_TFNRFNIF BIT(0)
+
+#define MCP25XXFD_CAN_FIFOUA(x) (0x58 + 0xc * (x))
+
+#define MCP25XXFD_CAN_FLTCON(x) (0x1d0 + (x))
+#define MCP25XXFD_CAN_FLTCON_FLTEN3 BIT(31)
+#define MCP25XXFD_CAN_FLTCON_F3BP_MASK GENMASK(28, 24)
+#define MCP25XXFD_CAN_FLTCON_FLTEN2 BIT(23)
+#define MCP25XXFD_CAN_FLTCON_F2BP_MASK GENMASK(20, 16)
+#define MCP25XXFD_CAN_FLTCON_FLTEN1 BIT(15)
+#define MCP25XXFD_CAN_FLTCON_F1BP_MASK GENMASK(12, 8)
+#define MCP25XXFD_CAN_FLTCON_FLTEN0 BIT(7)
+#define MCP25XXFD_CAN_FLTCON_F0BP_MASK GENMASK(4, 0)
+
+#define MCP25XXFD_CAN_FLTOBJ(x) (0x1f0 + 8 * (x))
+#define MCP25XXFD_CAN_FLTOBJ_EXIDE BIT(30)
+#define MCP25XXFD_CAN_FLTOBJ_SID11 BIT(29)
+#define MCP25XXFD_CAN_FLTOBJ_EID_MASK GENMASK(28, 11)
+#define MCP25XXFD_CAN_FLTOBJ_SID_MASK GENMASK(10, 0)
+
+#define MCP25XXFD_CAN_FLTMASK(x) (0x1f4 + 8 * (x))
+#define MCP25XXFD_CAN_MASK_MIDE BIT(30)
+#define MCP25XXFD_CAN_MASK_MSID11 BIT(29)
+#define MCP25XXFD_CAN_MASK_MEID_MASK GENMASK(28, 11)
+#define MCP25XXFD_CAN_MASK_MSID_MASK GENMASK(10, 0)
+
+/* RAM */
+#define MCP25XXFD_RAM_SIZE 2048
+#define MCP25XXFD_RAM_START 0x400
+
+/* Message Object */
+#define MCP25XXFD_OBJ_ID_SID11 BIT(29)
+#define MCP25XXFD_OBJ_ID_EID_MASK GENMASK(28, 11)
+#define MCP25XXFD_OBJ_ID_SID_MASK GENMASK(10, 0)
+#define MCP25XXFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK GENMASK(31, 9)
+#define MCP25XXFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK GENMASK(15, 9)
+#define MCP25XXFD_OBJ_FLAGS_SEQ_MASK MCP25XXFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK
+#define MCP25XXFD_OBJ_FLAGS_ESI BIT(8)
+#define MCP25XXFD_OBJ_FLAGS_FDF BIT(7)
+#define MCP25XXFD_OBJ_FLAGS_BRS BIT(6)
+#define MCP25XXFD_OBJ_FLAGS_RTR BIT(5)
+#define MCP25XXFD_OBJ_FLAGS_IDE BIT(4)
+#define MCP25XXFD_OBJ_FLAGS_DLC GENMASK(3, 0)
+
+#define MCP25XXFD_CAN_FRAME_EFF_SID_MASK GENMASK(28, 18)
+#define MCP25XXFD_CAN_FRAME_EFF_EID_MASK GENMASK(17, 0)
+
+/* MCP2517/18FD SFR */
+#define MCP25XXFD_OSC 0xe00
+#define MCP25XXFD_OSC_SCLKRDY BIT(12)
+#define MCP25XXFD_OSC_OSCRDY BIT(10)
+#define MCP25XXFD_OSC_PLLRDY BIT(8)
+#define MCP25XXFD_OSC_CLKODIV_10 3
+#define MCP25XXFD_OSC_CLKODIV_4 2
+#define MCP25XXFD_OSC_CLKODIV_2 1
+#define MCP25XXFD_OSC_CLKODIV_1 0
+#define MCP25XXFD_OSC_CLKODIV_MASK GENMASK(6, 5)
+#define MCP25XXFD_OSC_SCLKDIV BIT(4)
+#define MCP25XXFD_OSC_LPMEN BIT(3)	/* MCP2518FD only */
+#define MCP25XXFD_OSC_OSCDIS BIT(2)
+#define MCP25XXFD_OSC_PLLEN BIT(0)
+
+#define MCP25XXFD_IOCON 0xe04
+#define MCP25XXFD_IOCON_INTOD BIT(30)
+#define MCP25XXFD_IOCON_SOF BIT(29)
+#define MCP25XXFD_IOCON_TXCANOD BIT(28)
+#define MCP25XXFD_IOCON_PM1 BIT(25)
+#define MCP25XXFD_IOCON_PM0 BIT(24)
+#define MCP25XXFD_IOCON_GPIO1 BIT(17)
+#define MCP25XXFD_IOCON_GPIO0 BIT(16)
+#define MCP25XXFD_IOCON_LAT1 BIT(9)
+#define MCP25XXFD_IOCON_LAT0 BIT(8)
+#define MCP25XXFD_IOCON_XSTBYEN BIT(6)
+#define MCP25XXFD_IOCON_TRIS1 BIT(1)
+#define MCP25XXFD_IOCON_TRIS0 BIT(0)
+
+#define MCP25XXFD_CRC 0xe08
+#define MCP25XXFD_CRC_FERRIE BIT(25)
+#define MCP25XXFD_CRC_CRCERRIE BIT(24)
+#define MCP25XXFD_CRC_FERRIF BIT(17)
+#define MCP25XXFD_CRC_CRCERRIF BIT(16)
+#define MCP25XXFD_CRC_IF_MASK GENMASK(17, 16)
+#define MCP25XXFD_CRC_MASK GENMASK(15, 0)
+
+#define MCP25XXFD_ECCCON 0xe0c
+#define MCP25XXFD_ECCCON_PARITY_MASK GENMASK(14, 8)
+#define MCP25XXFD_ECCCON_DEDIE BIT(2)
+#define MCP25XXFD_ECCCON_SECIE BIT(1)
+#define MCP25XXFD_ECCCON_ECCEN BIT(0)
+
+#define MCP25XXFD_ECCSTAT 0xe10
+#define MCP25XXFD_ECCSTAT_ERRADDR_MASK GENMASK(27, 16)
+#define MCP25XXFD_ECCSTAT_IF_MASK GENMASK(2, 1)
+#define MCP25XXFD_ECCSTAT_DEDIF BIT(2)
+#define MCP25XXFD_ECCSTAT_SECIF BIT(1)
+
+#define MCP25XXFD_DEVID 0xe14	/* MCP2518FD only */
+#define MCP25XXFD_DEVID_ID_MASK GENMASK(7, 4)
+#define MCP25XXFD_DEVID_REV_MASK GENMASK(3, 0)
+
+/* number of TX FIFO objects, depending on CAN mode
+ *
+ * FIFO setup: tef: 8*12 bytes = 96 bytes, tx: 8*16 bytes = 128, rx: 32*20 bytes =  640 bytes, free: 1184 bytes.
+ * FIFO setup: tef: 4*12 bytes = 48 bytes, tx: 4*72 bytes = 288, rx: 22*76 bytes = 1672 bytes, free:   40 bytes.
+ */
+#define MCP25XXFD_TX_OBJ_NUM_CAN 8
+#define MCP25XXFD_TX_OBJ_NUM_CANFD 4
+
+#if MCP25XXFD_TX_OBJ_NUM_CAN > MCP25XXFD_TX_OBJ_NUM_CANFD
+#define MCP25XXFD_TX_OBJ_NUM_MAX MCP25XXFD_TX_OBJ_NUM_CAN
+#else
+#define MCP25XXFD_TX_OBJ_NUM_MAX MCP25XXFD_TX_OBJ_NUM_CANFD
+#endif
+
+/* The actual number of RX objects is calculated in
+ * mcp25xxfd_chip_fifo_compute(), but we allocate memory
+ * beforehand.
+ */
+#define MCP25XXFD_RX_OBJ_NUM_CAN 32
+#define MCP25XXFD_RX_OBJ_NUM_CANFD 22
+
+#define MCP25XXFD_NAPI_WEIGHT 32
+#define MCP25XXFD_TX_FIFO 1
+#define MCP25XXFD_RX_FIFO(x) (MCP25XXFD_TX_FIFO + 1 + (x))
+#define MCP25XXFD_RX_FIFO_NUM (1)
+
+/* SPI commands */
+#define MCP25XXFD_INSTRUCTION_RESET 0x0000
+#define MCP25XXFD_INSTRUCTION_WRITE 0x2000
+#define MCP25XXFD_INSTRUCTION_READ 0x3000
+#define MCP25XXFD_INSTRUCTION_WRITE_CRC 0xa000
+#define MCP25XXFD_INSTRUCTION_READ_CRC 0xb000
+#define MCP25XXFD_INSTRUCTION_WRITE_SAVE 0xc000
+
+struct mcp25xxfd_dump_regs_fifo {
+	u32 con;
+	u32 sta;
+	u32 ua;
+};
+
+struct mcp25xxfd_dump_regs {
+	u32 con;
+	u32 nbtcfg;
+	u32 dbtcfg;
+	u32 tdc;
+	u32 tbc;
+	u32 tscon;
+	u32 vec;
+	u32 intf;
+	u32 rxif;
+	u32 txif;
+	u32 rxovif;
+	u32 txatif;
+	u32 txreq;
+	u32 trec;
+	u32 bdiag0;
+	u32 bdiag1;
+	union {
+		struct {
+			u32 tefcon;
+			u32 tefsta;
+			u32 tefua;
+		};
+		struct mcp25xxfd_dump_regs_fifo tef;
+	};
+	u32 reserved0;
+	union {
+		struct {
+			struct mcp25xxfd_dump_regs_fifo txq;
+			struct mcp25xxfd_dump_regs_fifo tx_fifo;
+			struct mcp25xxfd_dump_regs_fifo rx_fifo;
+		};
+		struct mcp25xxfd_dump_regs_fifo fifo[32];
+	};
+};
+
+struct mcp25xxfd_dump_ram {
+	u8 ram[MCP25XXFD_RAM_SIZE];
+};
+
+struct mcp25xxfd_dump_regs_mcp25xxfd {
+	u32 osc;
+	u32 iocon;
+	u32 crc;
+	u32 ecccon;
+	u32 eccstat;
+	u32 devid;		/* MCP2518FD only */
+};
+
+struct mcp25xxfd_dump {
+	struct mcp25xxfd_dump_regs regs;
+	struct mcp25xxfd_dump_ram ram;
+	struct mcp25xxfd_dump_regs_mcp25xxfd regs_mcp25xxfd;
+};
+
+struct mcp25xxfd_hw_tef_obj {
+	u32 id;
+	u32 flags;
+	u32 ts;
+};
+
+/* The tx_obj_raw version is used in spi async, i.e. without
+ * regmap. We have to take care of endianness ourselves.
+ */
+struct mcp25xxfd_hw_tx_obj_raw {
+	__le32 id;
+	__le32 flags;
+	u8 data[FIELD_SIZEOF(struct canfd_frame, data)];
+};
+
+struct mcp25xxfd_hw_tx_obj_can {
+	u32 id;
+	u32 flags;
+	u8 data[FIELD_SIZEOF(struct can_frame, data)];
+};
+
+struct mcp25xxfd_hw_tx_obj_canfd {
+	u32 id;
+	u32 flags;
+	u8 data[FIELD_SIZEOF(struct canfd_frame, data)];
+};
+
+struct mcp25xxfd_hw_rx_obj_can {
+	u32 id;
+	u32 flags;
+	u32 ts;
+	u8 data[FIELD_SIZEOF(struct can_frame, data)];
+};
+
+struct mcp25xxfd_hw_rx_obj_canfd {
+	u32 id;
+	u32 flags;
+	u32 ts;
+	u8 data[FIELD_SIZEOF(struct canfd_frame, data)];
+};
+
+struct __packed mcp25xxfd_tx_obj_load_buf {
+	__be16 cmd;
+	struct mcp25xxfd_hw_tx_obj_raw hw_tx_obj;
+} ____cacheline_aligned;
+
+struct __packed mcp25xxfd_reg_write_buf {
+	__be16 cmd;
+	u8 data[4];
+} ____cacheline_aligned;
+
+struct mcp25xxfd_crc_buf {
+	struct __packed {
+		__be16 cmd;
+		u8 len;
+	} addr;
+	__be16 crc;
+} ____cacheline_aligned;
+
+struct mcp25xxfd_tef_ring {
+	unsigned int head;
+	unsigned int tail;
+
+	/* u8 obj_num equals tx_ring->obj_num */
+	/* u8 obj_size equals sizeof(struct mcp25xxfd_hw_tef_obj) */
+};
+
+struct mcp25xxfd_tx_obj {
+	struct {
+		struct spi_message msg;
+		struct spi_transfer xfer;
+		struct mcp25xxfd_tx_obj_load_buf buf;
+	} load;
+
+	struct {
+		struct spi_message msg;
+		struct spi_transfer xfer;
+		struct mcp25xxfd_reg_write_buf buf;
+	} trigger;
+};
+
+struct mcp25xxfd_tx_ring {
+	unsigned int head;
+	unsigned int tail;
+
+	u8 obj_num;
+	u8 obj_size;
+
+	struct mcp25xxfd_tx_obj obj[MCP25XXFD_TX_OBJ_NUM_MAX];
+};
+
+struct mcp25xxfd_rx_ring {
+	unsigned int head;
+	unsigned int tail;
+
+	u8 obj_num;
+	u8 obj_size;
+
+	struct mcp25xxfd_hw_rx_obj_canfd obj[MCP25XXFD_RX_OBJ_NUM_CANFD];
+};
+
+struct mcp25xxfd_regs_status {
+	u32 intf;
+};
+
+enum mcp25xxfd_model {
+	CAN_MCP2517FD = 0x2517,
+	CAN_MCP2518FD = 0x2518,
+	CAN_MCP25XXFD = 0xffff,		/* autodetect model */
+};
+
+struct mcp25xxfd_priv {
+	struct can_priv can;
+	struct can_rx_offload offload;
+	struct net_device *ndev;
+
+	struct regmap *map;
+	struct regmap *map_crc;
+	struct spi_device *spi;
+
+	struct mcp25xxfd_tef_ring tef;
+	struct mcp25xxfd_tx_ring tx;
+	struct mcp25xxfd_rx_ring rx;
+
+	u32 intf;
+
+	struct mcp25xxfd_reg_write_buf update_bits_buf;
+	struct mcp25xxfd_crc_buf crc_buf;
+
+	struct gpio_desc *rx_int;
+	struct gpio_desc *gpiod_xceiver;
+	struct clk *clk;
+	struct regulator *reg_vdd;
+	struct regulator *reg_xceiver;
+
+	enum mcp25xxfd_model model;
+
+	struct mcp25xxfd_dump dump;
+	atomic_t cnt;
+#ifdef CONFIG_CAN_MCP25XXFD_LOG
+	struct mcp25xxfd_log log[64];
+#endif
+};
+
+static inline u8 mcp25xxfd_first_byte_set(u32 mask)
+{
+	return (mask & 0x0000ffff) ?
+		((mask & 0x000000ff) ? 0 : 1) :
+		((mask & 0x00ff0000) ? 2 : 3);
+}
+
+static inline u8 mcp25xxfd_last_byte_set(u32 mask)
+{
+	return (mask & 0xffff0000) ?
+		((mask & 0xff000000) ? 3 : 2) :
+		((mask & 0x0000ff00) ? 1 : 0);
+}
+
+static inline __be16 mcp25xxfd_cmd_reset(void)
+{
+	return cpu_to_be16(MCP25XXFD_INSTRUCTION_RESET);
+}
+
+static inline __be16 mcp25xxfd_cmd_read(u16 addr)
+{
+	return cpu_to_be16(MCP25XXFD_INSTRUCTION_READ | addr);
+}
+
+static inline __be16 mcp25xxfd_cmd_write(u16 addr)
+{
+	return cpu_to_be16(MCP25XXFD_INSTRUCTION_WRITE | addr);
+}
+
+static inline u16
+mcp25xxfd_get_tef_obj_rel_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return sizeof(struct mcp25xxfd_hw_tef_obj) * n;
+}
+
+static inline u16
+mcp25xxfd_get_tef_obj_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return mcp25xxfd_get_tef_obj_rel_addr(priv, n) + MCP25XXFD_RAM_START;
+}
+
+static inline u16
+mcp25xxfd_get_tx_obj_rel_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return mcp25xxfd_get_tef_obj_rel_addr(priv, priv->tx.obj_num) +
+		priv->tx.obj_size * n;
+}
+
+static inline u16
+mcp25xxfd_get_tx_obj_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return mcp25xxfd_get_tx_obj_rel_addr(priv, n) + MCP25XXFD_RAM_START;
+}
+
+static inline u16
+mcp25xxfd_get_rx_obj_rel_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return mcp25xxfd_get_tx_obj_rel_addr(priv, priv->tx.obj_num) +
+		priv->rx.obj_size * n;
+}
+
+static inline u16
+mcp25xxfd_get_rx_obj_addr(const struct mcp25xxfd_priv *priv, u8 n)
+{
+	return mcp25xxfd_get_rx_obj_rel_addr(priv, n) + MCP25XXFD_RAM_START;
+}
+
+static inline u8 mcp25xxfd_get_tef_head(const struct mcp25xxfd_priv *priv)
+{
+	return priv->tef.head & (priv->tx.obj_num - 1);
+}
+
+static inline u8 mcp25xxfd_get_tef_tail(const struct mcp25xxfd_priv *priv)
+{
+	return priv->tef.tail & (priv->tx.obj_num - 1);
+}
+
+static inline u8 mcp25xxfd_get_tef_len(const struct mcp25xxfd_priv *priv)
+{
+	return priv->tef.head - priv->tef.tail;
+}
+
+static inline u8 mcp25xxfd_get_tef_linear_len(const struct mcp25xxfd_priv *priv)
+{
+	u8 len;
+
+	len = mcp25xxfd_get_tef_len(priv);
+
+	return min_t(u8, len, priv->tx.obj_num - mcp25xxfd_get_tef_tail(priv));
+}
+
+static inline u8 mcp25xxfd_get_tx_head(const struct mcp25xxfd_priv *priv)
+{
+	return priv->tx.head & (priv->tx.obj_num - 1);
+}
+
+static inline u8 mcp25xxfd_get_tx_tail(const struct mcp25xxfd_priv *priv)
+{
+	return priv->tx.tail & (priv->tx.obj_num - 1);
+}
+
+static inline u8 mcp25xxfd_get_rx_head(const struct mcp25xxfd_priv *priv)
+{
+	return priv->rx.head & (priv->rx.obj_num - 1);
+}
+
+static inline u8 mcp25xxfd_get_rx_tail(const struct mcp25xxfd_priv *priv)
+{
+	return priv->rx.tail & (priv->rx.obj_num - 1);
+}
+
+static inline u8 mcp25xxfd_get_rx_len(const struct mcp25xxfd_priv *priv)
+{
+	return priv->rx.head - priv->rx.tail;
+}
+
+static inline u8 mcp25xxfd_get_rx_linear_len(const struct mcp25xxfd_priv *priv)
+{
+	u8 len;
+
+	len = mcp25xxfd_get_rx_len(priv);
+
+	return min_t(u8, len, priv->rx.obj_num - mcp25xxfd_get_rx_tail(priv));
+}
+
+void mcp25xxfd_dump(struct mcp25xxfd_priv *priv);
+int mcp25xxfd_regmap_init(struct mcp25xxfd_priv *priv);
+u16 mcp25xxfd_crc16_compute(const void *cmd, size_t cmd_size,
+			    const void *data, size_t data_size);
+
+#endif
diff --git a/drivers/net/can/ti_hecc.c b/drivers/net/can/ti_hecc.c
index 31ad364a89bb..d0a05fc5cc32 100644
--- a/drivers/net/can/ti_hecc.c
+++ b/drivers/net/can/ti_hecc.c
@@ -873,7 +873,8 @@ static int ti_hecc_probe(struct platform_device *pdev)
 	priv->base = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(priv->base)) {
 		dev_err(&pdev->dev, "hecc ioremap failed\n");
-		return PTR_ERR(priv->base);
+		err = PTR_ERR(priv->base);
+		goto probe_exit_candev;
 	}
 
 	/* handle hecc-ram memory */
@@ -886,7 +887,8 @@ static int ti_hecc_probe(struct platform_device *pdev)
 	priv->hecc_ram = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(priv->hecc_ram)) {
 		dev_err(&pdev->dev, "hecc-ram ioremap failed\n");
-		return PTR_ERR(priv->hecc_ram);
+		err = PTR_ERR(priv->hecc_ram);
+		goto probe_exit_candev;
 	}
 
 	/* handle mbx memory */
@@ -899,13 +901,14 @@ static int ti_hecc_probe(struct platform_device *pdev)
 	priv->mbx = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(priv->mbx)) {
 		dev_err(&pdev->dev, "mbx ioremap failed\n");
-		return PTR_ERR(priv->mbx);
+		err = PTR_ERR(priv->mbx);
+		goto probe_exit_candev;
 	}
 
 	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!irq) {
 		dev_err(&pdev->dev, "No irq resource\n");
-		goto probe_exit;
+		goto probe_exit_candev;
 	}
 
 	priv->ndev = ndev;
@@ -936,7 +939,7 @@ static int ti_hecc_probe(struct platform_device *pdev)
 	err = clk_prepare_enable(priv->clk);
 	if (err) {
 		dev_err(&pdev->dev, "clk_prepare_enable() failed\n");
-		goto probe_exit_clk;
+		goto probe_exit_release_clk;
 	}
 
 	priv->offload.mailbox_read = ti_hecc_mailbox_read;
@@ -945,7 +948,7 @@ static int ti_hecc_probe(struct platform_device *pdev)
 	err = can_rx_offload_add_timestamp(ndev, &priv->offload);
 	if (err) {
 		dev_err(&pdev->dev, "can_rx_offload_add_timestamp() failed\n");
-		goto probe_exit_clk;
+		goto probe_exit_disable_clk;
 	}
 
 	err = register_candev(ndev);
@@ -963,11 +966,13 @@ static int ti_hecc_probe(struct platform_device *pdev)
 
 probe_exit_offload:
 	can_rx_offload_del(&priv->offload);
-probe_exit_clk:
+probe_exit_disable_clk:
+	clk_disable_unprepare(priv->clk);
+probe_exit_release_clk:
 	clk_put(priv->clk);
 probe_exit_candev:
 	free_candev(ndev);
-probe_exit:
+
 	return err;
 }
 
diff --git a/drivers/net/can/usb/gs_usb.c b/drivers/net/can/usb/gs_usb.c
index a4b4b742c80c..0ad13d78815c 100644
--- a/drivers/net/can/usb/gs_usb.c
+++ b/drivers/net/can/usb/gs_usb.c
@@ -63,21 +63,27 @@ enum gs_can_identify_mode {
 };
 
 /* data types passed between host and device */
+
+/* The firmware on the original USB2CAN by Geschwister Schneider
+ * Technologie Entwicklungs- und Vertriebs UG exchanges all data
+ * between the host and the device in host byte order. This is done
+ * with the struct gs_host_config::byte_order member, which is sent
+ * first to indicate the desired byte order.
+ *
+ * The widely used open source firmware candleLight doesn't support
+ * this feature and exchanges the data in little endian byte order.
+ */
 struct gs_host_config {
-	u32 byte_order;
+	__le32 byte_order;
 } __packed;
-/* All data exchanged between host and device is exchanged in host byte order,
- * thanks to the struct gs_host_config byte_order member, which is sent first
- * to indicate the desired byte order.
- */
 
 struct gs_device_config {
 	u8 reserved1;
 	u8 reserved2;
 	u8 reserved3;
 	u8 icount;
-	u32 sw_version;
-	u32 hw_version;
+	__le32 sw_version;
+	__le32 hw_version;
 } __packed;
 
 #define GS_CAN_MODE_NORMAL               0
@@ -87,26 +93,26 @@ struct gs_device_config {
 #define GS_CAN_MODE_ONE_SHOT             BIT(3)
 
 struct gs_device_mode {
-	u32 mode;
-	u32 flags;
+	__le32 mode;
+	__le32 flags;
 } __packed;
 
 struct gs_device_state {
-	u32 state;
-	u32 rxerr;
-	u32 txerr;
+	__le32 state;
+	__le32 rxerr;
+	__le32 txerr;
 } __packed;
 
 struct gs_device_bittiming {
-	u32 prop_seg;
-	u32 phase_seg1;
-	u32 phase_seg2;
-	u32 sjw;
-	u32 brp;
+	__le32 prop_seg;
+	__le32 phase_seg1;
+	__le32 phase_seg2;
+	__le32 sjw;
+	__le32 brp;
 } __packed;
 
 struct gs_identify_mode {
-	u32 mode;
+	__le32 mode;
 } __packed;
 
 #define GS_CAN_FEATURE_LISTEN_ONLY      BIT(0)
@@ -117,23 +123,23 @@ struct gs_identify_mode {
 #define GS_CAN_FEATURE_IDENTIFY         BIT(5)
 
 struct gs_device_bt_const {
-	u32 feature;
-	u32 fclk_can;
-	u32 tseg1_min;
-	u32 tseg1_max;
-	u32 tseg2_min;
-	u32 tseg2_max;
-	u32 sjw_max;
-	u32 brp_min;
-	u32 brp_max;
-	u32 brp_inc;
+	__le32 feature;
+	__le32 fclk_can;
+	__le32 tseg1_min;
+	__le32 tseg1_max;
+	__le32 tseg2_min;
+	__le32 tseg2_max;
+	__le32 sjw_max;
+	__le32 brp_min;
+	__le32 brp_max;
+	__le32 brp_inc;
 } __packed;
 
 #define GS_CAN_FLAG_OVERFLOW 1
 
 struct gs_host_frame {
 	u32 echo_id;
-	u32 can_id;
+	__le32 can_id;
 
 	u8 can_dlc;
 	u8 channel;
@@ -329,13 +335,13 @@ static void gs_usb_receive_bulk_callback(struct urb *urb)
 		if (!skb)
 			return;
 
-		cf->can_id = hf->can_id;
+		cf->can_id = le32_to_cpu(hf->can_id);
 
 		cf->can_dlc = get_can_dlc(hf->can_dlc);
 		memcpy(cf->data, hf->data, 8);
 
 		/* ERROR frames tell us information about the controller */
-		if (hf->can_id & CAN_ERR_FLAG)
+		if (le32_to_cpu(hf->can_id) & CAN_ERR_FLAG)
 			gs_update_state(dev, cf);
 
 		netdev->stats.rx_packets++;
@@ -418,11 +424,11 @@ static int gs_usb_set_bittiming(struct net_device *netdev)
 	if (!dbt)
 		return -ENOMEM;
 
-	dbt->prop_seg = bt->prop_seg;
-	dbt->phase_seg1 = bt->phase_seg1;
-	dbt->phase_seg2 = bt->phase_seg2;
-	dbt->sjw = bt->sjw;
-	dbt->brp = bt->brp;
+	dbt->prop_seg = cpu_to_le32(bt->prop_seg);
+	dbt->phase_seg1 = cpu_to_le32(bt->phase_seg1);
+	dbt->phase_seg2 = cpu_to_le32(bt->phase_seg2);
+	dbt->sjw = cpu_to_le32(bt->sjw);
+	dbt->brp = cpu_to_le32(bt->brp);
 
 	/* request bit timings */
 	rc = usb_control_msg(interface_to_usbdev(intf),
@@ -503,7 +509,7 @@ static netdev_tx_t gs_can_start_xmit(struct sk_buff *skb,
 
 	cf = (struct can_frame *)skb->data;
 
-	hf->can_id = cf->can_id;
+	hf->can_id = cpu_to_le32(cf->can_id);
 	hf->can_dlc = cf->can_dlc;
 	memcpy(hf->data, cf->data, cf->can_dlc);
 
@@ -573,6 +579,7 @@ static int gs_can_open(struct net_device *netdev)
 	int rc, i;
 	struct gs_device_mode *dm;
 	u32 ctrlmode;
+	u32 flags = 0;
 
 	rc = open_candev(netdev);
 	if (rc)
@@ -640,24 +647,24 @@ static int gs_can_open(struct net_device *netdev)
 
 	/* flags */
 	ctrlmode = dev->can.ctrlmode;
-	dm->flags = 0;
 
 	if (ctrlmode & CAN_CTRLMODE_LOOPBACK)
-		dm->flags |= GS_CAN_MODE_LOOP_BACK;
+		flags |= GS_CAN_MODE_LOOP_BACK;
 	else if (ctrlmode & CAN_CTRLMODE_LISTENONLY)
-		dm->flags |= GS_CAN_MODE_LISTEN_ONLY;
+		flags |= GS_CAN_MODE_LISTEN_ONLY;
 
 	/* Controller is not allowed to retry TX
 	 * this mode is unavailable on atmels uc3c hardware
 	 */
 	if (ctrlmode & CAN_CTRLMODE_ONE_SHOT)
-		dm->flags |= GS_CAN_MODE_ONE_SHOT;
+		flags |= GS_CAN_MODE_ONE_SHOT;
 
 	if (ctrlmode & CAN_CTRLMODE_3_SAMPLES)
-		dm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE;
+		flags |= GS_CAN_MODE_TRIPLE_SAMPLE;
 
 	/* finally start device */
-	dm->mode = GS_CAN_MODE_START;
+	dm->mode = cpu_to_le32(GS_CAN_MODE_START);
+	dm->flags = cpu_to_le32(flags);
 	rc = usb_control_msg(interface_to_usbdev(dev->iface),
 			     usb_sndctrlpipe(interface_to_usbdev(dev->iface), 0),
 			     GS_USB_BREQ_MODE,
@@ -737,9 +744,9 @@ static int gs_usb_set_identify(struct net_device *netdev, bool do_identify)
 		return -ENOMEM;
 
 	if (do_identify)
-		imode->mode = GS_CAN_IDENTIFY_ON;
+		imode->mode = cpu_to_le32(GS_CAN_IDENTIFY_ON);
 	else
-		imode->mode = GS_CAN_IDENTIFY_OFF;
+		imode->mode = cpu_to_le32(GS_CAN_IDENTIFY_OFF);
 
 	rc = usb_control_msg(interface_to_usbdev(dev->iface),
 			     usb_sndctrlpipe(interface_to_usbdev(dev->iface),
@@ -790,6 +797,7 @@ static struct gs_can *gs_make_candev(unsigned int channel,
 	struct net_device *netdev;
 	int rc;
 	struct gs_device_bt_const *bt_const;
+	u32 feature;
 
 	bt_const = kmalloc(sizeof(*bt_const), GFP_KERNEL);
 	if (!bt_const)
@@ -830,14 +838,14 @@ static struct gs_can *gs_make_candev(unsigned int channel,
 
 	/* dev settup */
 	strcpy(dev->bt_const.name, "gs_usb");
-	dev->bt_const.tseg1_min = bt_const->tseg1_min;
-	dev->bt_const.tseg1_max = bt_const->tseg1_max;
-	dev->bt_const.tseg2_min = bt_const->tseg2_min;
-	dev->bt_const.tseg2_max = bt_const->tseg2_max;
-	dev->bt_const.sjw_max = bt_const->sjw_max;
-	dev->bt_const.brp_min = bt_const->brp_min;
-	dev->bt_const.brp_max = bt_const->brp_max;
-	dev->bt_const.brp_inc = bt_const->brp_inc;
+	dev->bt_const.tseg1_min = le32_to_cpu(bt_const->tseg1_min);
+	dev->bt_const.tseg1_max = le32_to_cpu(bt_const->tseg1_max);
+	dev->bt_const.tseg2_min = le32_to_cpu(bt_const->tseg2_min);
+	dev->bt_const.tseg2_max = le32_to_cpu(bt_const->tseg2_max);
+	dev->bt_const.sjw_max = le32_to_cpu(bt_const->sjw_max);
+	dev->bt_const.brp_min = le32_to_cpu(bt_const->brp_min);
+	dev->bt_const.brp_max = le32_to_cpu(bt_const->brp_max);
+	dev->bt_const.brp_inc = le32_to_cpu(bt_const->brp_inc);
 
 	dev->udev = interface_to_usbdev(intf);
 	dev->iface = intf;
@@ -854,28 +862,29 @@ static struct gs_can *gs_make_candev(unsigned int channel,
 
 	/* can settup */
 	dev->can.state = CAN_STATE_STOPPED;
-	dev->can.clock.freq = bt_const->fclk_can;
+	dev->can.clock.freq = le32_to_cpu(bt_const->fclk_can);
 	dev->can.bittiming_const = &dev->bt_const;
 	dev->can.do_set_bittiming = gs_usb_set_bittiming;
 
 	dev->can.ctrlmode_supported = 0;
 
-	if (bt_const->feature & GS_CAN_FEATURE_LISTEN_ONLY)
+	feature = le32_to_cpu(bt_const->feature);
+	if (feature & GS_CAN_FEATURE_LISTEN_ONLY)
 		dev->can.ctrlmode_supported |= CAN_CTRLMODE_LISTENONLY;
 
-	if (bt_const->feature & GS_CAN_FEATURE_LOOP_BACK)
+	if (feature & GS_CAN_FEATURE_LOOP_BACK)
 		dev->can.ctrlmode_supported |= CAN_CTRLMODE_LOOPBACK;
 
-	if (bt_const->feature & GS_CAN_FEATURE_TRIPLE_SAMPLE)
+	if (feature & GS_CAN_FEATURE_TRIPLE_SAMPLE)
 		dev->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;
 
-	if (bt_const->feature & GS_CAN_FEATURE_ONE_SHOT)
+	if (feature & GS_CAN_FEATURE_ONE_SHOT)
 		dev->can.ctrlmode_supported |= CAN_CTRLMODE_ONE_SHOT;
 
 	SET_NETDEV_DEV(netdev, &intf->dev);
 
-	if (dconf->sw_version > 1)
-		if (bt_const->feature & GS_CAN_FEATURE_IDENTIFY)
+	if (le32_to_cpu(dconf->sw_version) > 1)
+		if (feature & GS_CAN_FEATURE_IDENTIFY)
 			netdev->ethtool_ops = &gs_usb_ethtool_ops;
 
 	kfree(bt_const);
@@ -910,7 +919,7 @@ static int gs_usb_probe(struct usb_interface *intf,
 	if (!hconf)
 		return -ENOMEM;
 
-	hconf->byte_order = 0x0000beef;
+	hconf->byte_order = cpu_to_le32(0x0000beef);
 
 	/* send host config */
 	rc = usb_control_msg(interface_to_usbdev(intf),
diff --git a/drivers/net/can/usb/kvaser_usb/kvaser_usb_hydra.c b/drivers/net/can/usb/kvaser_usb/kvaser_usb_hydra.c
index 7ab87a758754..218fadc91155 100644
--- a/drivers/net/can/usb/kvaser_usb/kvaser_usb_hydra.c
+++ b/drivers/net/can/usb/kvaser_usb/kvaser_usb_hydra.c
@@ -367,7 +367,7 @@ static const struct can_bittiming_const kvaser_usb_hydra_kcan_bittiming_c = {
 	.tseg2_max = 32,
 	.sjw_max = 16,
 	.brp_min = 1,
-	.brp_max = 4096,
+	.brp_max = 8192,
 	.brp_inc = 1,
 };
 
diff --git a/drivers/net/can/usb/mcba_usb.c b/drivers/net/can/usb/mcba_usb.c
index 21faa2ec4632..8f785c199e22 100644
--- a/drivers/net/can/usb/mcba_usb.c
+++ b/drivers/net/can/usb/mcba_usb.c
@@ -326,8 +326,6 @@ static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,
 	if (!ctx)
 		return NETDEV_TX_BUSY;
 
-	can_put_echo_skb(skb, priv->netdev, ctx->ndx);
-
 	if (cf->can_id & CAN_EFF_FLAG) {
 		/* SIDH    | SIDL                 | EIDH   | EIDL
 		 * 28 - 21 | 20 19 18 x x x 17 16 | 15 - 8 | 7 - 0
@@ -357,6 +355,8 @@ static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,
 	if (cf->can_id & CAN_RTR_FLAG)
 		usb_msg.dlc |= MCBA_DLC_RTR_MASK;
 
+	can_put_echo_skb(skb, priv->netdev, ctx->ndx);
+
 	err = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);
 	if (err)
 		goto xmit_failed;
diff --git a/drivers/net/can/usb/peak_usb/pcan_usb_core.c b/drivers/net/can/usb/peak_usb/pcan_usb_core.c
index 0b7766b715fd..f22089101cdd 100644
--- a/drivers/net/can/usb/peak_usb/pcan_usb_core.c
+++ b/drivers/net/can/usb/peak_usb/pcan_usb_core.c
@@ -130,14 +130,55 @@ void peak_usb_get_ts_time(struct peak_time_ref *time_ref, u32 ts, ktime_t *time)
 	/* protect from getting time before setting now */
 	if (ktime_to_ns(time_ref->tv_host)) {
 		u64 delta_us;
+		s64 delta_ts = 0;
+
+		/* General case: dev_ts_1 < dev_ts_2 < ts, with:
+		 *
+		 * - dev_ts_1 = previous sync timestamp
+		 * - dev_ts_2 = last sync timestamp
+		 * - ts = event timestamp
+		 * - ts_period = known sync period (theoretical)
+		 *             ~ dev_ts2 - dev_ts1
+		 * *but*:
+		 *
+		 * - time counters wrap (see adapter->ts_used_bits)
+		 * - sometimes, dev_ts_1 < ts < dev_ts2
+		 *
+		 * "normal" case (sync time counters increase):
+		 * must take into account case when ts wraps (tsw)
+		 *
+		 *      < ts_period > <          >
+		 *     |             |            |
+		 *  ---+--------+----+-------0-+--+-->
+		 *     ts_dev_1 |    ts_dev_2  |
+		 *              ts             tsw
+		 */
+		if (time_ref->ts_dev_1 < time_ref->ts_dev_2) {
+			/* case when event time (tsw) wraps */
+			if (ts < time_ref->ts_dev_1)
+				delta_ts = BIT_ULL(time_ref->adapter->ts_used_bits);
+
+		/* Otherwise, sync time counter (ts_dev_2) has wrapped:
+		 * handle case when event time (tsn) hasn't.
+		 *
+		 *      < ts_period > <          >
+		 *     |             |            |
+		 *  ---+--------+--0-+---------+--+-->
+		 *     ts_dev_1 |    ts_dev_2  |
+		 *              tsn            ts
+		 */
+		} else if (time_ref->ts_dev_1 < ts) {
+			delta_ts = -BIT_ULL(time_ref->adapter->ts_used_bits);
+		}
 
-		delta_us = ts - time_ref->ts_dev_2;
-		if (ts < time_ref->ts_dev_2)
-			delta_us &= (1 << time_ref->adapter->ts_used_bits) - 1;
+		/* add delay between last sync and event timestamps */
+		delta_ts += (signed int)(ts - time_ref->ts_dev_2);
 
-		delta_us += time_ref->ts_total;
+		/* add time from beginning to last sync */
+		delta_ts += time_ref->ts_total;
 
-		delta_us *= time_ref->adapter->us_per_ts_scale;
+		/* convert ticks number into microseconds */
+		delta_us = delta_ts * time_ref->adapter->us_per_ts_scale;
 		delta_us >>= time_ref->adapter->us_per_ts_shift;
 
 		*time = ktime_add_us(time_ref->tv_host_0, delta_us);
diff --git a/drivers/net/can/usb/peak_usb/pcan_usb_fd.c b/drivers/net/can/usb/peak_usb/pcan_usb_fd.c
index 47cc1ff5b88e..96bbdef672bc 100644
--- a/drivers/net/can/usb/peak_usb/pcan_usb_fd.c
+++ b/drivers/net/can/usb/peak_usb/pcan_usb_fd.c
@@ -468,12 +468,18 @@ static int pcan_usb_fd_decode_canmsg(struct pcan_usb_fd_if *usb_if,
 				     struct pucan_msg *rx_msg)
 {
 	struct pucan_rx_msg *rm = (struct pucan_rx_msg *)rx_msg;
-	struct peak_usb_device *dev = usb_if->dev[pucan_msg_get_channel(rm)];
-	struct net_device *netdev = dev->netdev;
+	struct peak_usb_device *dev;
+	struct net_device *netdev;
 	struct canfd_frame *cfd;
 	struct sk_buff *skb;
 	const u16 rx_msg_flags = le16_to_cpu(rm->flags);
 
+	if (pucan_msg_get_channel(rm) >= ARRAY_SIZE(usb_if->dev))
+		return -ENOMEM;
+
+	dev = usb_if->dev[pucan_msg_get_channel(rm)];
+	netdev = dev->netdev;
+
 	if (rx_msg_flags & PUCAN_MSG_EXT_DATA_LEN) {
 		/* CANFD frame case */
 		skb = alloc_canfd_skb(netdev, &cfd);
@@ -506,11 +512,11 @@ static int pcan_usb_fd_decode_canmsg(struct pcan_usb_fd_if *usb_if,
 	else
 		memcpy(cfd->data, rm->d, cfd->len);
 
-	peak_usb_netif_rx(skb, &usb_if->time_ref, le32_to_cpu(rm->ts_low));
-
 	netdev->stats.rx_packets++;
 	netdev->stats.rx_bytes += cfd->len;
 
+	peak_usb_netif_rx(skb, &usb_if->time_ref, le32_to_cpu(rm->ts_low));
+
 	return 0;
 }
 
@@ -519,15 +525,21 @@ static int pcan_usb_fd_decode_status(struct pcan_usb_fd_if *usb_if,
 				     struct pucan_msg *rx_msg)
 {
 	struct pucan_status_msg *sm = (struct pucan_status_msg *)rx_msg;
-	struct peak_usb_device *dev = usb_if->dev[pucan_stmsg_get_channel(sm)];
-	struct pcan_usb_fd_device *pdev =
-			container_of(dev, struct pcan_usb_fd_device, dev);
+	struct pcan_usb_fd_device *pdev;
 	enum can_state new_state = CAN_STATE_ERROR_ACTIVE;
 	enum can_state rx_state, tx_state;
-	struct net_device *netdev = dev->netdev;
+	struct peak_usb_device *dev;
+	struct net_device *netdev;
 	struct can_frame *cf;
 	struct sk_buff *skb;
 
+	if (pucan_stmsg_get_channel(sm) >= ARRAY_SIZE(usb_if->dev))
+		return -ENOMEM;
+
+	dev = usb_if->dev[pucan_stmsg_get_channel(sm)];
+	pdev = container_of(dev, struct pcan_usb_fd_device, dev);
+	netdev = dev->netdev;
+
 	/* nothing should be sent while in BUS_OFF state */
 	if (dev->can.state == CAN_STATE_BUS_OFF)
 		return 0;
@@ -566,11 +578,11 @@ static int pcan_usb_fd_decode_status(struct pcan_usb_fd_if *usb_if,
 	if (!skb)
 		return -ENOMEM;
 
-	peak_usb_netif_rx(skb, &usb_if->time_ref, le32_to_cpu(sm->ts_low));
-
 	netdev->stats.rx_packets++;
 	netdev->stats.rx_bytes += cf->can_dlc;
 
+	peak_usb_netif_rx(skb, &usb_if->time_ref, le32_to_cpu(sm->ts_low));
+
 	return 0;
 }
 
@@ -579,9 +591,14 @@ static int pcan_usb_fd_decode_error(struct pcan_usb_fd_if *usb_if,
 				    struct pucan_msg *rx_msg)
 {
 	struct pucan_error_msg *er = (struct pucan_error_msg *)rx_msg;
-	struct peak_usb_device *dev = usb_if->dev[pucan_ermsg_get_channel(er)];
-	struct pcan_usb_fd_device *pdev =
-			container_of(dev, struct pcan_usb_fd_device, dev);
+	struct pcan_usb_fd_device *pdev;
+	struct peak_usb_device *dev;
+
+	if (pucan_ermsg_get_channel(er) >= ARRAY_SIZE(usb_if->dev))
+		return -EINVAL;
+
+	dev = usb_if->dev[pucan_ermsg_get_channel(er)];
+	pdev = container_of(dev, struct pcan_usb_fd_device, dev);
 
 	/* keep a trace of tx and rx error counters for later use */
 	pdev->bec.txerr = er->tx_err_cnt;
@@ -595,11 +612,17 @@ static int pcan_usb_fd_decode_overrun(struct pcan_usb_fd_if *usb_if,
 				      struct pucan_msg *rx_msg)
 {
 	struct pcan_ufd_ovr_msg *ov = (struct pcan_ufd_ovr_msg *)rx_msg;
-	struct peak_usb_device *dev = usb_if->dev[pufd_omsg_get_channel(ov)];
-	struct net_device *netdev = dev->netdev;
+	struct peak_usb_device *dev;
+	struct net_device *netdev;
 	struct can_frame *cf;
 	struct sk_buff *skb;
 
+	if (pufd_omsg_get_channel(ov) >= ARRAY_SIZE(usb_if->dev))
+		return -EINVAL;
+
+	dev = usb_if->dev[pufd_omsg_get_channel(ov)];
+	netdev = dev->netdev;
+
 	/* allocate an skb to store the error frame */
 	skb = alloc_can_err_skb(netdev, &cf);
 	if (!skb)
@@ -716,6 +739,9 @@ static int pcan_usb_fd_encode_msg(struct peak_usb_device *dev,
 	u16 tx_msg_size, tx_msg_flags;
 	u8 can_dlc;
 
+	if (cfd->len > CANFD_MAX_DLEN)
+		return -EINVAL;
+
 	tx_msg_size = ALIGN(sizeof(struct pucan_tx_msg) + cfd->len, 4);
 	tx_msg->size = cpu_to_le16(tx_msg_size);
 	tx_msg->type = cpu_to_le16(PUCAN_MSG_CAN_TX);
diff --git a/drivers/net/can/vcan.c b/drivers/net/can/vcan.c
index 39ca14b0585d..067705e2850b 100644
--- a/drivers/net/can/vcan.c
+++ b/drivers/net/can/vcan.c
@@ -153,7 +153,7 @@ static void vcan_setup(struct net_device *dev)
 	dev->addr_len		= 0;
 	dev->tx_queue_len	= 0;
 	dev->flags		= IFF_NOARP;
-	dev->ml_priv		= netdev_priv(dev);
+	can_set_ml_priv(dev, netdev_priv(dev));
 
 	/* set flags according to driver capabilities */
 	if (echo)
diff --git a/drivers/net/can/vxcan.c b/drivers/net/can/vxcan.c
index d6ba9426be4d..7000c6cd1e48 100644
--- a/drivers/net/can/vxcan.c
+++ b/drivers/net/can/vxcan.c
@@ -39,6 +39,7 @@ static netdev_tx_t vxcan_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct net_device *peer;
 	struct canfd_frame *cfd = (struct canfd_frame *)skb->data;
 	struct net_device_stats *peerstats, *srcstats = &dev->stats;
+	u8 len;
 
 	if (can_dropped_invalid_skb(dev, skb))
 		return NETDEV_TX_OK;
@@ -61,12 +62,13 @@ static netdev_tx_t vxcan_xmit(struct sk_buff *skb, struct net_device *dev)
 	skb->dev        = peer;
 	skb->ip_summed  = CHECKSUM_UNNECESSARY;
 
+	len = cfd->len;
 	if (netif_rx_ni(skb) == NET_RX_SUCCESS) {
 		srcstats->tx_packets++;
-		srcstats->tx_bytes += cfd->len;
+		srcstats->tx_bytes += len;
 		peerstats = &peer->stats;
 		peerstats->rx_packets++;
-		peerstats->rx_bytes += cfd->len;
+		peerstats->rx_bytes += len;
 	}
 
 out_unlock:
@@ -139,6 +141,8 @@ static const struct net_device_ops vxcan_netdev_ops = {
 
 static void vxcan_setup(struct net_device *dev)
 {
+	struct can_ml_priv *can_ml;
+
 	dev->type		= ARPHRD_CAN;
 	dev->mtu		= CANFD_MTU;
 	dev->hard_header_len	= 0;
@@ -147,7 +151,9 @@ static void vxcan_setup(struct net_device *dev)
 	dev->flags		= (IFF_NOARP|IFF_ECHO);
 	dev->netdev_ops		= &vxcan_netdev_ops;
 	dev->needs_free_netdev	= true;
-	dev->ml_priv		= netdev_priv(dev) + ALIGN(sizeof(struct vxcan_priv), NETDEV_ALIGN);
+
+	can_ml = netdev_priv(dev) + ALIGN(sizeof(struct vxcan_priv), NETDEV_ALIGN);
+	can_set_ml_priv(dev, can_ml);
 }
 
 /* forward declaration for rtnl_create_link() */
diff --git a/drivers/net/can/xilinx_can.c b/drivers/net/can/xilinx_can.c
index 2be846ee627d..0de39ebb3566 100644
--- a/drivers/net/can/xilinx_can.c
+++ b/drivers/net/can/xilinx_can.c
@@ -1384,7 +1384,7 @@ static int xcan_open(struct net_device *ndev)
 	if (ret < 0) {
 		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
 			   __func__, ret);
-		return ret;
+		goto err;
 	}
 
 	ret = request_irq(ndev->irq, xcan_interrupt, priv->irq_flags,
@@ -1468,6 +1468,7 @@ static int xcan_get_berr_counter(const struct net_device *ndev,
 	if (ret < 0) {
 		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
 			   __func__, ret);
+		pm_runtime_put(priv->dev);
 		return ret;
 	}
 
@@ -1783,7 +1784,7 @@ static int xcan_probe(struct platform_device *pdev)
 	if (ret < 0) {
 		netdev_err(ndev, "%s: pm_runtime_get failed(%d)\n",
 			   __func__, ret);
-		goto err_pmdisable;
+		goto err_disableclks;
 	}
 
 	if (priv->read_reg(priv, XCAN_SR_OFFSET) != XCAN_SR_CONFIG_MASK) {
@@ -1818,7 +1819,6 @@ static int xcan_probe(struct platform_device *pdev)
 
 err_disableclks:
 	pm_runtime_put(priv->dev);
-err_pmdisable:
 	pm_runtime_disable(&pdev->dev);
 err_free:
 	free_candev(ndev);
diff --git a/include/linux/can/can-ml.h b/include/linux/can/can-ml.h
index 2f5d731ae251..8afa92d15a66 100644
--- a/include/linux/can/can-ml.h
+++ b/include/linux/can/can-ml.h
@@ -44,6 +44,7 @@
 
 #include <linux/can.h>
 #include <linux/list.h>
+#include <linux/netdevice.h>
 
 #define CAN_SFF_RCV_ARRAY_SZ (1 << CAN_SFF_ID_BITS)
 #define CAN_EFF_RCV_HASH_BITS 10
@@ -65,4 +66,15 @@ struct can_ml_priv {
 #endif
 };
 
+static inline struct can_ml_priv *can_get_ml_priv(struct net_device *dev)
+{
+	return netdev_get_ml_priv(dev, ML_PRIV_CAN);
+}
+
+static inline void can_set_ml_priv(struct net_device *dev,
+				   struct can_ml_priv *ml_priv)
+{
+	netdev_set_ml_priv(dev, ml_priv, ML_PRIV_CAN);
+}
+
 #endif /* CAN_ML_H */
diff --git a/include/linux/can/platform/mcp251x.h b/include/linux/can/platform/mcp251x.h
deleted file mode 100644
index 9e5ac27fb6c1..000000000000
--- a/include/linux/can/platform/mcp251x.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef _CAN_PLATFORM_MCP251X_H
-#define _CAN_PLATFORM_MCP251X_H
-
-/*
- *
- * CAN bus driver for Microchip 251x CAN Controller with SPI Interface
- *
- */
-
-#include <linux/spi/spi.h>
-
-/*
- * struct mcp251x_platform_data - MCP251X SPI CAN controller platform data
- * @oscillator_frequency:       - oscillator frequency in Hz
- */
-
-struct mcp251x_platform_data {
-	unsigned long oscillator_frequency;
-};
-
-#endif /* !_CAN_PLATFORM_MCP251X_H */
diff --git a/include/linux/can/rx-offload.h b/include/linux/can/rx-offload.h
index 1b78a0cfb615..f1b38088b765 100644
--- a/include/linux/can/rx-offload.h
+++ b/include/linux/can/rx-offload.h
@@ -35,6 +35,9 @@ int can_rx_offload_add_timestamp(struct net_device *dev,
 int can_rx_offload_add_fifo(struct net_device *dev,
 			    struct can_rx_offload *offload,
 			    unsigned int weight);
+int can_rx_offload_add_manual(struct net_device *dev,
+			      struct can_rx_offload *offload,
+			      unsigned int weight);
 int can_rx_offload_irq_offload_timestamp(struct can_rx_offload *offload,
 					 u64 reg);
 int can_rx_offload_irq_offload_fifo(struct can_rx_offload *offload);
diff --git a/include/linux/can/skb.h b/include/linux/can/skb.h
index a954def26c0d..1ef071e5a55e 100644
--- a/include/linux/can/skb.h
+++ b/include/linux/can/skb.h
@@ -49,8 +49,12 @@ static inline void can_skb_reserve(struct sk_buff *skb)
 
 static inline void can_skb_set_owner(struct sk_buff *skb, struct sock *sk)
 {
-	if (sk) {
-		sock_hold(sk);
+	/* If the socket has already been closed by user space, the
+	 * refcount may already be 0 (and the socket will be freed
+	 * after the last TX skb has been freed). So only increase
+	 * socket refcount if the refcount is > 0.
+	 */
+	if (sk && refcount_inc_not_zero(&sk->sk_refcnt)) {
 		skb->destructor = sock_efree;
 		skb->sk = sk;
 	}
@@ -61,21 +65,17 @@ static inline void can_skb_set_owner(struct sk_buff *skb, struct sock *sk)
  */
 static inline struct sk_buff *can_create_echo_skb(struct sk_buff *skb)
 {
-	if (skb_shared(skb)) {
-		struct sk_buff *nskb = skb_clone(skb, GFP_ATOMIC);
+	struct sk_buff *nskb;
 
-		if (likely(nskb)) {
-			can_skb_set_owner(nskb, skb->sk);
-			consume_skb(skb);
-			return nskb;
-		} else {
-			kfree_skb(skb);
-			return NULL;
-		}
+	nskb = skb_clone(skb, GFP_ATOMIC);
+	if (unlikely(!nskb)) {
+		kfree_skb(skb);
+		return NULL;
 	}
 
-	/* we can assume to have an unshared skb with proper owner */
-	return skb;
+	can_skb_set_owner(nskb, skb->sk);
+	consume_skb(skb);
+	return nskb;
 }
 
 #endif /* !_CAN_SKB_H */
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index b580a35f50ea..11a52f2fa35d 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1555,6 +1555,12 @@ enum netdev_priv_flags {
 #define IFF_L3MDEV_RX_HANDLER		IFF_L3MDEV_RX_HANDLER
 #define IFF_LIVE_RENAME_OK		IFF_LIVE_RENAME_OK
 
+/* Specifies the type of the struct net_device::ml_priv pointer */
+enum netdev_ml_priv_type {
+	ML_PRIV_NONE,
+	ML_PRIV_CAN,
+};
+
 /**
  *	struct net_device - The DEVICE structure.
  *
@@ -1732,6 +1738,7 @@ enum netdev_priv_flags {
  * 	@nd_net:		Network namespace this network device is inside
  *
  * 	@ml_priv:	Mid-layer private
+ *	@ml_priv_type:  Mid-layer private type
  * 	@lstats:	Loopback statistics
  * 	@tstats:	Tunnel statistics
  * 	@dstats:	Dummy statistics
@@ -2019,8 +2026,10 @@ struct net_device {
 	possible_net_t			nd_net;
 
 	/* mid-layer private */
+	void				*ml_priv;
+	enum netdev_ml_priv_type	ml_priv_type;
+
 	union {
-		void					*ml_priv;
 		struct pcpu_lstats __percpu		*lstats;
 		struct pcpu_sw_netstats __percpu	*tstats;
 		struct pcpu_dstats __percpu		*dstats;
@@ -2167,6 +2176,29 @@ static inline void netdev_reset_rx_headroom(struct net_device *dev)
 	netdev_set_rx_headroom(dev, -1);
 }
 
+static inline void *netdev_get_ml_priv(struct net_device *dev,
+				       enum netdev_ml_priv_type type)
+{
+	if (dev->ml_priv_type != type)
+		return NULL;
+
+	return dev->ml_priv;
+}
+
+static inline void netdev_set_ml_priv(struct net_device *dev,
+				      void *ml_priv,
+				      enum netdev_ml_priv_type type)
+{
+	WARN(dev->ml_priv_type && dev->ml_priv_type != type,
+	     "Overwriting already set ml_priv_type (%u) with different ml_priv_type (%u)!\n",
+	     dev->ml_priv_type, type);
+	WARN(!dev->ml_priv_type && dev->ml_priv,
+	     "Overwriting already set ml_priv and ml_priv_type is ML_PRIV_NONE!\n");
+
+	dev->ml_priv = ml_priv;
+	dev->ml_priv_type = type;
+}
+
 /*
  * Net namespace inlines
  */
@@ -3043,7 +3075,7 @@ static inline int dev_recursion_level(void)
 	return this_cpu_read(softnet_data.xmit.recursion);
 }
 
-#define XMIT_RECURSION_LIMIT	10
+#define XMIT_RECURSION_LIMIT	8
 static inline bool dev_xmit_recursion(void)
 {
 	return unlikely(__this_cpu_read(softnet_data.xmit.recursion) >
@@ -3679,6 +3711,9 @@ int dev_pre_changeaddr_notify(struct net_device *dev, const char *addr,
 			      struct netlink_ext_ack *extack);
 int dev_set_mac_address(struct net_device *dev, struct sockaddr *sa,
 			struct netlink_ext_ack *extack);
+int dev_set_mac_address_user(struct net_device *dev, struct sockaddr *sa,
+			     struct netlink_ext_ack *extack);
+int dev_get_mac_address(struct sockaddr *sa, struct net *net, char *dev_name);
 int dev_change_carrier(struct net_device *, bool new_carrier);
 int dev_get_phys_port_id(struct net_device *dev,
 			 struct netdev_phys_item_id *ppid);
@@ -4044,6 +4079,7 @@ static inline void netif_tx_disable(struct net_device *dev)
 
 	local_bh_disable();
 	cpu = smp_processor_id();
+	spin_lock(&dev->tx_global_lock);
 	for (i = 0; i < dev->num_tx_queues; i++) {
 		struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
 
@@ -4051,6 +4087,7 @@ static inline void netif_tx_disable(struct net_device *dev)
 		netif_tx_stop_queue(txq);
 		__netif_tx_unlock(txq);
 	}
+	spin_unlock(&dev->tx_global_lock);
 	local_bh_enable();
 }
 
diff --git a/include/net/rtnetlink.h b/include/net/rtnetlink.h
index e2091bb2b3a8..4da61c950e93 100644
--- a/include/net/rtnetlink.h
+++ b/include/net/rtnetlink.h
@@ -33,6 +33,7 @@ static inline int rtnl_msg_family(const struct nlmsghdr *nlh)
  *
  *	@list: Used internally
  *	@kind: Identifier
+ *	@netns_refund: Physical device, move to init_net on netns exit
  *	@maxtype: Highest device specific netlink attribute number
  *	@policy: Netlink policy for device specific attribute validation
  *	@validate: Optional validation function for netlink/changelink parameters
@@ -64,6 +65,7 @@ struct rtnl_link_ops {
 	size_t			priv_size;
 	void			(*setup)(struct net_device *dev);
 
+	bool			netns_refund;
 	unsigned int		maxtype;
 	const struct nla_policy	*policy;
 	int			(*validate)(struct nlattr *tb[],
-- 
2.25.1

